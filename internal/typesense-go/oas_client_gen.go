// Code generated by ogen, DO NOT EDIT.

package typesense

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateAnalyticsEvent invokes createAnalyticsEvent operation.
	//
	// Sending events for analytics e.g rank search results based on popularity.
	//
	// POST /analytics/events
	CreateAnalyticsEvent(ctx context.Context, request *AnalyticsEventCreateSchema) (CreateAnalyticsEventRes, error)
	// CreateAnalyticsRule invokes createAnalyticsRule operation.
	//
	// When an analytics rule is created, we give it a name and describe the type, the source collections
	// and the destination collection.
	//
	// POST /analytics/rules
	CreateAnalyticsRule(ctx context.Context, request *AnalyticsRuleSchema) (CreateAnalyticsRuleRes, error)
	// CreateCollection invokes createCollection operation.
	//
	// When a collection is created, we give it a name and describe the fields that will be indexed from
	// the documents added to the collection.
	//
	// POST /collections
	CreateCollection(ctx context.Context, request *CollectionSchema) (CreateCollectionRes, error)
	// CreateConversationModel invokes createConversationModel operation.
	//
	// Create a Conversation Model.
	//
	// POST /conversations/models
	CreateConversationModel(ctx context.Context, request *ConversationModelCreateSchema) (CreateConversationModelRes, error)
	// CreateKey invokes createKey operation.
	//
	// Create an API Key with fine-grain access control. You can restrict access on both a per-collection
	// and per-action level. The generated key is returned only during creation. You want to store this
	// key carefully in a secure place.
	//
	// POST /keys
	CreateKey(ctx context.Context, request OptApiKeySchema) (CreateKeyRes, error)
	// CreateNLSearchModel invokes createNLSearchModel operation.
	//
	// Create a new NL search model.
	//
	// POST /nl_search_models
	CreateNLSearchModel(ctx context.Context, request *NLSearchModelCreateSchema) (CreateNLSearchModelRes, error)
	// Debug invokes debug operation.
	//
	// Print debugging information.
	//
	// GET /debug
	Debug(ctx context.Context) (*DebugOK, error)
	// DeleteAlias invokes deleteAlias operation.
	//
	// Delete an alias.
	//
	// DELETE /aliases/{aliasName}
	DeleteAlias(ctx context.Context, params DeleteAliasParams) (DeleteAliasRes, error)
	// DeleteAnalyticsRule invokes deleteAnalyticsRule operation.
	//
	// Permanently deletes an analytics rule, given it's name.
	//
	// DELETE /analytics/rules/{ruleName}
	DeleteAnalyticsRule(ctx context.Context, params DeleteAnalyticsRuleParams) (DeleteAnalyticsRuleRes, error)
	// DeleteCollection invokes deleteCollection operation.
	//
	// Permanently drops a collection. This action cannot be undone. For large collections, this might
	// have an impact on read latencies.
	//
	// DELETE /collections/{collectionName}
	DeleteCollection(ctx context.Context, params DeleteCollectionParams) (DeleteCollectionRes, error)
	// DeleteConversationModel invokes deleteConversationModel operation.
	//
	// Delete a conversation model.
	//
	// DELETE /conversations/models/{modelId}
	DeleteConversationModel(ctx context.Context, params DeleteConversationModelParams) (*ConversationModelSchema, error)
	// DeleteDocument invokes deleteDocument operation.
	//
	// Delete an individual document from a collection by using its ID.
	//
	// DELETE /collections/{collectionName}/documents/{documentId}
	DeleteDocument(ctx context.Context, params DeleteDocumentParams) (DeleteDocumentRes, error)
	// DeleteDocuments invokes deleteDocuments operation.
	//
	// Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter
	// to control the number of documents that should deleted at a time. A larger value will speed up
	// deletions, but will impact performance of other operations running on the server.
	//
	// DELETE /collections/{collectionName}/documents
	DeleteDocuments(ctx context.Context, params DeleteDocumentsParams) (DeleteDocumentsRes, error)
	// DeleteKey invokes deleteKey operation.
	//
	// Delete an API key given its ID.
	//
	// DELETE /keys/{keyId}
	DeleteKey(ctx context.Context, params DeleteKeyParams) (DeleteKeyRes, error)
	// DeleteNLSearchModel invokes deleteNLSearchModel operation.
	//
	// Delete a specific NL search model by its ID.
	//
	// DELETE /nl_search_models/{modelId}
	DeleteNLSearchModel(ctx context.Context, params DeleteNLSearchModelParams) (DeleteNLSearchModelRes, error)
	// DeletePreset invokes deletePreset operation.
	//
	// Permanently deletes a preset, given it's name.
	//
	// DELETE /presets/{presetId}
	DeletePreset(ctx context.Context, params DeletePresetParams) (DeletePresetRes, error)
	// DeleteSearchOverride invokes deleteSearchOverride operation.
	//
	// Delete an override associated with a collection.
	//
	// DELETE /collections/{collectionName}/overrides/{overrideId}
	DeleteSearchOverride(ctx context.Context, params DeleteSearchOverrideParams) (DeleteSearchOverrideRes, error)
	// DeleteSearchSynonym invokes deleteSearchSynonym operation.
	//
	// Delete a synonym associated with a collection.
	//
	// DELETE /collections/{collectionName}/synonyms/{synonymId}
	DeleteSearchSynonym(ctx context.Context, params DeleteSearchSynonymParams) (DeleteSearchSynonymRes, error)
	// DeleteStopwordsSet invokes deleteStopwordsSet operation.
	//
	// Permanently deletes a stopwords set, given it's name.
	//
	// DELETE /stopwords/{setId}
	DeleteStopwordsSet(ctx context.Context, params DeleteStopwordsSetParams) (DeleteStopwordsSetRes, error)
	// ExportDocuments invokes exportDocuments operation.
	//
	// Export all documents in a collection in JSON lines format.
	//
	// GET /collections/{collectionName}/documents/export
	ExportDocuments(ctx context.Context, params ExportDocumentsParams) (ExportDocumentsRes, error)
	// GetAlias invokes getAlias operation.
	//
	// Find out which collection an alias points to by fetching it.
	//
	// GET /aliases/{aliasName}
	GetAlias(ctx context.Context, params GetAliasParams) (GetAliasRes, error)
	// GetAliases invokes getAliases operation.
	//
	// List all aliases and the corresponding collections that they map to.
	//
	// GET /aliases
	GetAliases(ctx context.Context) (*CollectionAliasesResponse, error)
	// GetCollection invokes getCollection operation.
	//
	// Retrieve the details of a collection, given its name.
	//
	// GET /collections/{collectionName}
	GetCollection(ctx context.Context, params GetCollectionParams) (GetCollectionRes, error)
	// GetCollections invokes getCollections operation.
	//
	// Returns a summary of all your collections. The collections are returned sorted by creation date,
	// with the most recent collections appearing first.
	//
	// GET /collections
	GetCollections(ctx context.Context, params GetCollectionsParams) ([]CollectionResponse, error)
	// GetDocument invokes getDocument operation.
	//
	// Fetch an individual document from a collection by using its ID.
	//
	// GET /collections/{collectionName}/documents/{documentId}
	GetDocument(ctx context.Context, params GetDocumentParams) (GetDocumentRes, error)
	// GetKey invokes getKey operation.
	//
	// Retrieve (metadata about) a key. Only the key prefix is returned when you retrieve a key. Due to
	// security reasons, only the create endpoint returns the full API key.
	//
	// GET /keys/{keyId}
	GetKey(ctx context.Context, params GetKeyParams) (GetKeyRes, error)
	// GetKeys invokes getKeys operation.
	//
	// Retrieve (metadata about) all keys.
	//
	// GET /keys
	GetKeys(ctx context.Context) (*ApiKeysResponse, error)
	// GetSchemaChanges invokes getSchemaChanges operation.
	//
	// Returns the status of any ongoing schema change operations. If no schema changes are in progress,
	// returns an empty response.
	//
	// GET /operations/schema_changes
	GetSchemaChanges(ctx context.Context) ([]SchemaChangeStatus, error)
	// GetSearchOverride invokes getSearchOverride operation.
	//
	// Retrieve the details of a search override, given its id.
	//
	// GET /collections/{collectionName}/overrides/{overrideId}
	GetSearchOverride(ctx context.Context, params GetSearchOverrideParams) (*SearchOverride, error)
	// GetSearchOverrides invokes getSearchOverrides operation.
	//
	// List all collection overrides.
	//
	// GET /collections/{collectionName}/overrides
	GetSearchOverrides(ctx context.Context, params GetSearchOverridesParams) (*SearchOverridesResponse, error)
	// GetSearchSynonym invokes getSearchSynonym operation.
	//
	// Retrieve the details of a search synonym, given its id.
	//
	// GET /collections/{collectionName}/synonyms/{synonymId}
	GetSearchSynonym(ctx context.Context, params GetSearchSynonymParams) (GetSearchSynonymRes, error)
	// GetSearchSynonyms invokes getSearchSynonyms operation.
	//
	// List all collection synonyms.
	//
	// GET /collections/{collectionName}/synonyms
	GetSearchSynonyms(ctx context.Context, params GetSearchSynonymsParams) (GetSearchSynonymsRes, error)
	// GetStemmingDictionary invokes getStemmingDictionary operation.
	//
	// Fetch details of a specific stemming dictionary.
	//
	// GET /stemming/dictionaries/{dictionaryId}
	GetStemmingDictionary(ctx context.Context, params GetStemmingDictionaryParams) (GetStemmingDictionaryRes, error)
	// Health invokes health operation.
	//
	// Checks if Typesense server is ready to accept requests.
	//
	// GET /health
	Health(ctx context.Context) (*HealthStatus, error)
	// ImportDocuments invokes importDocuments operation.
	//
	// The documents to be imported must be formatted in a newline delimited JSON structure. You can feed
	// the output file from a Typesense export operation directly as import.
	//
	// POST /collections/{collectionName}/documents/import
	ImportDocuments(ctx context.Context, request ImportDocumentsReq, params ImportDocumentsParams) (ImportDocumentsRes, error)
	// ImportStemmingDictionary invokes importStemmingDictionary operation.
	//
	// Upload a JSONL file containing word mappings to create or update a stemming dictionary.
	//
	// POST /stemming/dictionaries/import
	ImportStemmingDictionary(ctx context.Context, request string, params ImportStemmingDictionaryParams) (ImportStemmingDictionaryRes, error)
	// IndexDocument invokes indexDocument operation.
	//
	// A document to be indexed in a given collection must conform to the schema of the collection.
	//
	// POST /collections/{collectionName}/documents
	IndexDocument(ctx context.Context, request *IndexDocumentReq, params IndexDocumentParams) (IndexDocumentRes, error)
	// ListStemmingDictionaries invokes listStemmingDictionaries operation.
	//
	// Retrieve a list of all available stemming dictionaries.
	//
	// GET /stemming/dictionaries
	ListStemmingDictionaries(ctx context.Context) (*ListStemmingDictionariesOK, error)
	// MultiSearch invokes multiSearch operation.
	//
	// This is especially useful to avoid round-trip network latencies incurred otherwise if each of
	// these requests are sent in separate HTTP requests. You can also use this feature to do a federated
	// search across multiple collections in a single HTTP request.
	//
	// POST /multi_search
	MultiSearch(ctx context.Context, request OptMultiSearchSearchesParameter, params MultiSearchParams) (MultiSearchRes, error)
	// RetrieveAPIStats invokes retrieveAPIStats operation.
	//
	// Retrieve the stats about API endpoints.
	//
	// GET /stats.json
	RetrieveAPIStats(ctx context.Context) (*APIStatsResponse, error)
	// RetrieveAllConversationModels invokes retrieveAllConversationModels operation.
	//
	// Retrieve all conversation models.
	//
	// GET /conversations/models
	RetrieveAllConversationModels(ctx context.Context) ([]ConversationModelSchema, error)
	// RetrieveAllNLSearchModels invokes retrieveAllNLSearchModels operation.
	//
	// Retrieve all NL search models.
	//
	// GET /nl_search_models
	RetrieveAllNLSearchModels(ctx context.Context) ([]NLSearchModelSchema, error)
	// RetrieveAllPresets invokes retrieveAllPresets operation.
	//
	// Retrieve the details of all presets.
	//
	// GET /presets
	RetrieveAllPresets(ctx context.Context) (*PresetsRetrieveSchema, error)
	// RetrieveAnalyticsRule invokes retrieveAnalyticsRule operation.
	//
	// Retrieve the details of an analytics rule, given it's name.
	//
	// GET /analytics/rules/{ruleName}
	RetrieveAnalyticsRule(ctx context.Context, params RetrieveAnalyticsRuleParams) (RetrieveAnalyticsRuleRes, error)
	// RetrieveAnalyticsRules invokes retrieveAnalyticsRules operation.
	//
	// Retrieve the details of all analytics rules.
	//
	// GET /analytics/rules
	RetrieveAnalyticsRules(ctx context.Context) (*AnalyticsRulesRetrieveSchema, error)
	// RetrieveConversationModel invokes retrieveConversationModel operation.
	//
	// Retrieve a conversation model.
	//
	// GET /conversations/models/{modelId}
	RetrieveConversationModel(ctx context.Context, params RetrieveConversationModelParams) (*ConversationModelSchema, error)
	// RetrieveMetrics invokes retrieveMetrics operation.
	//
	// Retrieve the metrics.
	//
	// GET /metrics.json
	RetrieveMetrics(ctx context.Context) error
	// RetrieveNLSearchModel invokes retrieveNLSearchModel operation.
	//
	// Retrieve a specific NL search model by its ID.
	//
	// GET /nl_search_models/{modelId}
	RetrieveNLSearchModel(ctx context.Context, params RetrieveNLSearchModelParams) (RetrieveNLSearchModelRes, error)
	// RetrievePreset invokes retrievePreset operation.
	//
	// Retrieve the details of a preset, given it's name.
	//
	// GET /presets/{presetId}
	RetrievePreset(ctx context.Context, params RetrievePresetParams) (RetrievePresetRes, error)
	// RetrieveStopwordsSet invokes retrieveStopwordsSet operation.
	//
	// Retrieve the details of a stopwords set, given it's name.
	//
	// GET /stopwords/{setId}
	RetrieveStopwordsSet(ctx context.Context, params RetrieveStopwordsSetParams) (RetrieveStopwordsSetRes, error)
	// RetrieveStopwordsSets invokes retrieveStopwordsSets operation.
	//
	// Retrieve the details of all stopwords sets.
	//
	// GET /stopwords
	RetrieveStopwordsSets(ctx context.Context) (*StopwordsSetsRetrieveAllSchema, error)
	// SearchCollection invokes searchCollection operation.
	//
	// Search for documents in a collection that match the search criteria.
	//
	// GET /collections/{collectionName}/documents/search
	SearchCollection(ctx context.Context, params SearchCollectionParams) (SearchCollectionRes, error)
	// TakeSnapshot invokes takeSnapshot operation.
	//
	// Creates a point-in-time snapshot of a Typesense node's state and data in the specified directory.
	// You can then backup the snapshot directory that gets created and later restore it as a data
	// directory, as needed.
	//
	// POST /operations/snapshot
	TakeSnapshot(ctx context.Context, params TakeSnapshotParams) (*SuccessStatus, error)
	// UpdateCollection invokes updateCollection operation.
	//
	// Update a collection's schema to modify the fields and their types.
	//
	// PATCH /collections/{collectionName}
	UpdateCollection(ctx context.Context, request *CollectionUpdateSchema, params UpdateCollectionParams) (UpdateCollectionRes, error)
	// UpdateConversationModel invokes updateConversationModel operation.
	//
	// Update a conversation model.
	//
	// PUT /conversations/models/{modelId}
	UpdateConversationModel(ctx context.Context, request *ConversationModelUpdateSchema, params UpdateConversationModelParams) (*ConversationModelSchema, error)
	// UpdateDocument invokes updateDocument operation.
	//
	// Update an individual document from a collection by using its ID. The update can be partial.
	//
	// PATCH /collections/{collectionName}/documents/{documentId}
	UpdateDocument(ctx context.Context, request *UpdateDocumentReq, params UpdateDocumentParams) (UpdateDocumentRes, error)
	// UpdateDocuments invokes updateDocuments operation.
	//
	// The filter_by query parameter is used to filter to specify a condition against which the documents
	// are matched. The request body contains the fields that should be updated for any documents that
	// match the filter condition. This endpoint is only available if the Typesense server is version `0.
	// 25.0.rc12` or later.
	//
	// PATCH /collections/{collectionName}/documents
	UpdateDocuments(ctx context.Context, request *UpdateDocumentsReq, params UpdateDocumentsParams) (UpdateDocumentsRes, error)
	// UpdateNLSearchModel invokes updateNLSearchModel operation.
	//
	// Update an existing NL search model.
	//
	// PUT /nl_search_models/{modelId}
	UpdateNLSearchModel(ctx context.Context, request *NLSearchModelCreateSchema, params UpdateNLSearchModelParams) (UpdateNLSearchModelRes, error)
	// UpsertAlias invokes upsertAlias operation.
	//
	// Create or update a collection alias. An alias is a virtual collection name that points to a real
	// collection. If you're familiar with symbolic links on Linux, it's very similar to that. Aliases
	// are useful when you want to reindex your data in the background on a new collection and switch
	// your application to it without any changes to your code.
	//
	// PUT /aliases/{aliasName}
	UpsertAlias(ctx context.Context, request OptCollectionAliasSchema, params UpsertAliasParams) (UpsertAliasRes, error)
	// UpsertAnalyticsRule invokes upsertAnalyticsRule operation.
	//
	// Upserts an analytics rule with the given name.
	//
	// PUT /analytics/rules/{ruleName}
	UpsertAnalyticsRule(ctx context.Context, request *AnalyticsRuleUpsertSchema, params UpsertAnalyticsRuleParams) (UpsertAnalyticsRuleRes, error)
	// UpsertPreset invokes upsertPreset operation.
	//
	// Create or update an existing preset.
	//
	// PUT /presets/{presetId}
	UpsertPreset(ctx context.Context, request *PresetUpsertSchema, params UpsertPresetParams) (UpsertPresetRes, error)
	// UpsertSearchOverride invokes upsertSearchOverride operation.
	//
	// Create or update an override to promote certain documents over others. Using overrides, you can
	// include or exclude specific documents for a given query.
	//
	// PUT /collections/{collectionName}/overrides/{overrideId}
	UpsertSearchOverride(ctx context.Context, request *SearchOverrideSchema, params UpsertSearchOverrideParams) (UpsertSearchOverrideRes, error)
	// UpsertSearchSynonym invokes upsertSearchSynonym operation.
	//
	// Create or update a synonym  to define search terms that should be considered equivalent.
	//
	// PUT /collections/{collectionName}/synonyms/{synonymId}
	UpsertSearchSynonym(ctx context.Context, request *SearchSynonymSchema, params UpsertSearchSynonymParams) (UpsertSearchSynonymRes, error)
	// UpsertStopwordsSet invokes upsertStopwordsSet operation.
	//
	// When an analytics rule is created, we give it a name and describe the type, the source collections
	// and the destination collection.
	//
	// PUT /stopwords/{setId}
	UpsertStopwordsSet(ctx context.Context, request *StopwordsSetUpsertSchema, params UpsertStopwordsSetParams) (UpsertStopwordsSetRes, error)
	// Vote invokes vote operation.
	//
	// Triggers a follower node to initiate the raft voting process, which triggers leader re-election.
	// The follower node that you run this operation against will become the new leader, once this
	// command succeeds.
	//
	// POST /operations/vote
	Vote(ctx context.Context) (*SuccessStatus, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CreateAnalyticsEvent invokes createAnalyticsEvent operation.
//
// Sending events for analytics e.g rank search results based on popularity.
//
// POST /analytics/events
func (c *Client) CreateAnalyticsEvent(ctx context.Context, request *AnalyticsEventCreateSchema) (CreateAnalyticsEventRes, error) {
	res, err := c.sendCreateAnalyticsEvent(ctx, request)
	return res, err
}

func (c *Client) sendCreateAnalyticsEvent(ctx context.Context, request *AnalyticsEventCreateSchema) (res CreateAnalyticsEventRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/analytics/events"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAnalyticsEventRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, CreateAnalyticsEventOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateAnalyticsEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAnalyticsRule invokes createAnalyticsRule operation.
//
// When an analytics rule is created, we give it a name and describe the type, the source collections
// and the destination collection.
//
// POST /analytics/rules
func (c *Client) CreateAnalyticsRule(ctx context.Context, request *AnalyticsRuleSchema) (CreateAnalyticsRuleRes, error) {
	res, err := c.sendCreateAnalyticsRule(ctx, request)
	return res, err
}

func (c *Client) sendCreateAnalyticsRule(ctx context.Context, request *AnalyticsRuleSchema) (res CreateAnalyticsRuleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/analytics/rules"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAnalyticsRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, CreateAnalyticsRuleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateAnalyticsRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCollection invokes createCollection operation.
//
// When a collection is created, we give it a name and describe the fields that will be indexed from
// the documents added to the collection.
//
// POST /collections
func (c *Client) CreateCollection(ctx context.Context, request *CollectionSchema) (CreateCollectionRes, error) {
	res, err := c.sendCreateCollection(ctx, request)
	return res, err
}

func (c *Client) sendCreateCollection(ctx context.Context, request *CollectionSchema) (res CreateCollectionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/collections"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCollectionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, CreateCollectionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCollectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateConversationModel invokes createConversationModel operation.
//
// Create a Conversation Model.
//
// POST /conversations/models
func (c *Client) CreateConversationModel(ctx context.Context, request *ConversationModelCreateSchema) (CreateConversationModelRes, error) {
	res, err := c.sendCreateConversationModel(ctx, request)
	return res, err
}

func (c *Client) sendCreateConversationModel(ctx context.Context, request *ConversationModelCreateSchema) (res CreateConversationModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/conversations/models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateConversationModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, CreateConversationModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateConversationModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateKey invokes createKey operation.
//
// Create an API Key with fine-grain access control. You can restrict access on both a per-collection
// and per-action level. The generated key is returned only during creation. You want to store this
// key carefully in a secure place.
//
// POST /keys
func (c *Client) CreateKey(ctx context.Context, request OptApiKeySchema) (CreateKeyRes, error) {
	res, err := c.sendCreateKey(ctx, request)
	return res, err
}

func (c *Client) sendCreateKey(ctx context.Context, request OptApiKeySchema) (res CreateKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, CreateKeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNLSearchModel invokes createNLSearchModel operation.
//
// Create a new NL search model.
//
// POST /nl_search_models
func (c *Client) CreateNLSearchModel(ctx context.Context, request *NLSearchModelCreateSchema) (CreateNLSearchModelRes, error) {
	res, err := c.sendCreateNLSearchModel(ctx, request)
	return res, err
}

func (c *Client) sendCreateNLSearchModel(ctx context.Context, request *NLSearchModelCreateSchema) (res CreateNLSearchModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/nl_search_models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNLSearchModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, CreateNLSearchModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNLSearchModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Debug invokes debug operation.
//
// Print debugging information.
//
// GET /debug
func (c *Client) Debug(ctx context.Context) (*DebugOK, error) {
	res, err := c.sendDebug(ctx)
	return res, err
}

func (c *Client) sendDebug(ctx context.Context) (res *DebugOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/debug"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DebugOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDebugResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAlias invokes deleteAlias operation.
//
// Delete an alias.
//
// DELETE /aliases/{aliasName}
func (c *Client) DeleteAlias(ctx context.Context, params DeleteAliasParams) (DeleteAliasRes, error) {
	res, err := c.sendDeleteAlias(ctx, params)
	return res, err
}

func (c *Client) sendDeleteAlias(ctx context.Context, params DeleteAliasParams) (res DeleteAliasRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/aliases/"
	{
		// Encode "aliasName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "aliasName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AliasName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteAliasOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAliasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAnalyticsRule invokes deleteAnalyticsRule operation.
//
// Permanently deletes an analytics rule, given it's name.
//
// DELETE /analytics/rules/{ruleName}
func (c *Client) DeleteAnalyticsRule(ctx context.Context, params DeleteAnalyticsRuleParams) (DeleteAnalyticsRuleRes, error) {
	res, err := c.sendDeleteAnalyticsRule(ctx, params)
	return res, err
}

func (c *Client) sendDeleteAnalyticsRule(ctx context.Context, params DeleteAnalyticsRuleParams) (res DeleteAnalyticsRuleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/analytics/rules/"
	{
		// Encode "ruleName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteAnalyticsRuleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAnalyticsRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCollection invokes deleteCollection operation.
//
// Permanently drops a collection. This action cannot be undone. For large collections, this might
// have an impact on read latencies.
//
// DELETE /collections/{collectionName}
func (c *Client) DeleteCollection(ctx context.Context, params DeleteCollectionParams) (DeleteCollectionRes, error) {
	res, err := c.sendDeleteCollection(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCollection(ctx context.Context, params DeleteCollectionParams) (res DeleteCollectionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteCollectionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCollectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteConversationModel invokes deleteConversationModel operation.
//
// Delete a conversation model.
//
// DELETE /conversations/models/{modelId}
func (c *Client) DeleteConversationModel(ctx context.Context, params DeleteConversationModelParams) (*ConversationModelSchema, error) {
	res, err := c.sendDeleteConversationModel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteConversationModel(ctx context.Context, params DeleteConversationModelParams) (res *ConversationModelSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/conversations/models/"
	{
		// Encode "modelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "modelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteConversationModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteConversationModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDocument invokes deleteDocument operation.
//
// Delete an individual document from a collection by using its ID.
//
// DELETE /collections/{collectionName}/documents/{documentId}
func (c *Client) DeleteDocument(ctx context.Context, params DeleteDocumentParams) (DeleteDocumentRes, error) {
	res, err := c.sendDeleteDocument(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDocument(ctx context.Context, params DeleteDocumentParams) (res DeleteDocumentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/"
	{
		// Encode "documentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteDocumentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDocuments invokes deleteDocuments operation.
//
// Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter
// to control the number of documents that should deleted at a time. A larger value will speed up
// deletions, but will impact performance of other operations running on the server.
//
// DELETE /collections/{collectionName}/documents
func (c *Client) DeleteDocuments(ctx context.Context, params DeleteDocumentsParams) (DeleteDocumentsRes, error) {
	res, err := c.sendDeleteDocuments(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDocuments(ctx context.Context, params DeleteDocumentsParams) (res DeleteDocumentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "deleteDocumentsParameters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "deleteDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DeleteDocumentsParameters.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteDocumentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteKey invokes deleteKey operation.
//
// Delete an API key given its ID.
//
// DELETE /keys/{keyId}
func (c *Client) DeleteKey(ctx context.Context, params DeleteKeyParams) (DeleteKeyRes, error) {
	res, err := c.sendDeleteKey(ctx, params)
	return res, err
}

func (c *Client) sendDeleteKey(ctx context.Context, params DeleteKeyParams) (res DeleteKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/keys/"
	{
		// Encode "keyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "keyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.KeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteKeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteNLSearchModel invokes deleteNLSearchModel operation.
//
// Delete a specific NL search model by its ID.
//
// DELETE /nl_search_models/{modelId}
func (c *Client) DeleteNLSearchModel(ctx context.Context, params DeleteNLSearchModelParams) (DeleteNLSearchModelRes, error) {
	res, err := c.sendDeleteNLSearchModel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteNLSearchModel(ctx context.Context, params DeleteNLSearchModelParams) (res DeleteNLSearchModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/nl_search_models/"
	{
		// Encode "modelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "modelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteNLSearchModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNLSearchModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePreset invokes deletePreset operation.
//
// Permanently deletes a preset, given it's name.
//
// DELETE /presets/{presetId}
func (c *Client) DeletePreset(ctx context.Context, params DeletePresetParams) (DeletePresetRes, error) {
	res, err := c.sendDeletePreset(ctx, params)
	return res, err
}

func (c *Client) sendDeletePreset(ctx context.Context, params DeletePresetParams) (res DeletePresetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/presets/"
	{
		// Encode "presetId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "presetId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PresetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeletePresetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeletePresetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSearchOverride invokes deleteSearchOverride operation.
//
// Delete an override associated with a collection.
//
// DELETE /collections/{collectionName}/overrides/{overrideId}
func (c *Client) DeleteSearchOverride(ctx context.Context, params DeleteSearchOverrideParams) (DeleteSearchOverrideRes, error) {
	res, err := c.sendDeleteSearchOverride(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSearchOverride(ctx context.Context, params DeleteSearchOverrideParams) (res DeleteSearchOverrideRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/overrides/"
	{
		// Encode "overrideId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "overrideId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OverrideId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteSearchOverrideOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSearchOverrideResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSearchSynonym invokes deleteSearchSynonym operation.
//
// Delete a synonym associated with a collection.
//
// DELETE /collections/{collectionName}/synonyms/{synonymId}
func (c *Client) DeleteSearchSynonym(ctx context.Context, params DeleteSearchSynonymParams) (DeleteSearchSynonymRes, error) {
	res, err := c.sendDeleteSearchSynonym(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSearchSynonym(ctx context.Context, params DeleteSearchSynonymParams) (res DeleteSearchSynonymRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/synonyms/"
	{
		// Encode "synonymId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "synonymId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SynonymId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteSearchSynonymOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSearchSynonymResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStopwordsSet invokes deleteStopwordsSet operation.
//
// Permanently deletes a stopwords set, given it's name.
//
// DELETE /stopwords/{setId}
func (c *Client) DeleteStopwordsSet(ctx context.Context, params DeleteStopwordsSetParams) (DeleteStopwordsSetRes, error) {
	res, err := c.sendDeleteStopwordsSet(ctx, params)
	return res, err
}

func (c *Client) sendDeleteStopwordsSet(ctx context.Context, params DeleteStopwordsSetParams) (res DeleteStopwordsSetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stopwords/"
	{
		// Encode "setId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "setId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, DeleteStopwordsSetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStopwordsSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportDocuments invokes exportDocuments operation.
//
// Export all documents in a collection in JSON lines format.
//
// GET /collections/{collectionName}/documents/export
func (c *Client) ExportDocuments(ctx context.Context, params ExportDocumentsParams) (ExportDocumentsRes, error) {
	res, err := c.sendExportDocuments(ctx, params)
	return res, err
}

func (c *Client) sendExportDocuments(ctx context.Context, params ExportDocumentsParams) (res ExportDocumentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/export"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "exportDocumentsParameters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exportDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExportDocumentsParameters.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, ExportDocumentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeExportDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAlias invokes getAlias operation.
//
// Find out which collection an alias points to by fetching it.
//
// GET /aliases/{aliasName}
func (c *Client) GetAlias(ctx context.Context, params GetAliasParams) (GetAliasRes, error) {
	res, err := c.sendGetAlias(ctx, params)
	return res, err
}

func (c *Client) sendGetAlias(ctx context.Context, params GetAliasParams) (res GetAliasRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/aliases/"
	{
		// Encode "aliasName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "aliasName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AliasName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetAliasOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAliasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAliases invokes getAliases operation.
//
// List all aliases and the corresponding collections that they map to.
//
// GET /aliases
func (c *Client) GetAliases(ctx context.Context) (*CollectionAliasesResponse, error) {
	res, err := c.sendGetAliases(ctx)
	return res, err
}

func (c *Client) sendGetAliases(ctx context.Context) (res *CollectionAliasesResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/aliases"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetAliasesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAliasesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCollection invokes getCollection operation.
//
// Retrieve the details of a collection, given its name.
//
// GET /collections/{collectionName}
func (c *Client) GetCollection(ctx context.Context, params GetCollectionParams) (GetCollectionRes, error) {
	res, err := c.sendGetCollection(ctx, params)
	return res, err
}

func (c *Client) sendGetCollection(ctx context.Context, params GetCollectionParams) (res GetCollectionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetCollectionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCollectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCollections invokes getCollections operation.
//
// Returns a summary of all your collections. The collections are returned sorted by creation date,
// with the most recent collections appearing first.
//
// GET /collections
func (c *Client) GetCollections(ctx context.Context, params GetCollectionsParams) ([]CollectionResponse, error) {
	res, err := c.sendGetCollections(ctx, params)
	return res, err
}

func (c *Client) sendGetCollections(ctx context.Context, params GetCollectionsParams) (res []CollectionResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/collections"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "getCollectionsParameters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "getCollectionsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GetCollectionsParameters.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetCollectionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCollectionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDocument invokes getDocument operation.
//
// Fetch an individual document from a collection by using its ID.
//
// GET /collections/{collectionName}/documents/{documentId}
func (c *Client) GetDocument(ctx context.Context, params GetDocumentParams) (GetDocumentRes, error) {
	res, err := c.sendGetDocument(ctx, params)
	return res, err
}

func (c *Client) sendGetDocument(ctx context.Context, params GetDocumentParams) (res GetDocumentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/"
	{
		// Encode "documentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetDocumentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetKey invokes getKey operation.
//
// Retrieve (metadata about) a key. Only the key prefix is returned when you retrieve a key. Due to
// security reasons, only the create endpoint returns the full API key.
//
// GET /keys/{keyId}
func (c *Client) GetKey(ctx context.Context, params GetKeyParams) (GetKeyRes, error) {
	res, err := c.sendGetKey(ctx, params)
	return res, err
}

func (c *Client) sendGetKey(ctx context.Context, params GetKeyParams) (res GetKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/keys/"
	{
		// Encode "keyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "keyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.KeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetKeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetKeys invokes getKeys operation.
//
// Retrieve (metadata about) all keys.
//
// GET /keys
func (c *Client) GetKeys(ctx context.Context) (*ApiKeysResponse, error) {
	res, err := c.sendGetKeys(ctx)
	return res, err
}

func (c *Client) sendGetKeys(ctx context.Context) (res *ApiKeysResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetKeysOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSchemaChanges invokes getSchemaChanges operation.
//
// Returns the status of any ongoing schema change operations. If no schema changes are in progress,
// returns an empty response.
//
// GET /operations/schema_changes
func (c *Client) GetSchemaChanges(ctx context.Context) ([]SchemaChangeStatus, error) {
	res, err := c.sendGetSchemaChanges(ctx)
	return res, err
}

func (c *Client) sendGetSchemaChanges(ctx context.Context) (res []SchemaChangeStatus, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/operations/schema_changes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetSchemaChangesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSchemaChangesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSearchOverride invokes getSearchOverride operation.
//
// Retrieve the details of a search override, given its id.
//
// GET /collections/{collectionName}/overrides/{overrideId}
func (c *Client) GetSearchOverride(ctx context.Context, params GetSearchOverrideParams) (*SearchOverride, error) {
	res, err := c.sendGetSearchOverride(ctx, params)
	return res, err
}

func (c *Client) sendGetSearchOverride(ctx context.Context, params GetSearchOverrideParams) (res *SearchOverride, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/overrides/"
	{
		// Encode "overrideId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "overrideId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OverrideId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetSearchOverrideOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSearchOverrideResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSearchOverrides invokes getSearchOverrides operation.
//
// List all collection overrides.
//
// GET /collections/{collectionName}/overrides
func (c *Client) GetSearchOverrides(ctx context.Context, params GetSearchOverridesParams) (*SearchOverridesResponse, error) {
	res, err := c.sendGetSearchOverrides(ctx, params)
	return res, err
}

func (c *Client) sendGetSearchOverrides(ctx context.Context, params GetSearchOverridesParams) (res *SearchOverridesResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/overrides"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetSearchOverridesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSearchOverridesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSearchSynonym invokes getSearchSynonym operation.
//
// Retrieve the details of a search synonym, given its id.
//
// GET /collections/{collectionName}/synonyms/{synonymId}
func (c *Client) GetSearchSynonym(ctx context.Context, params GetSearchSynonymParams) (GetSearchSynonymRes, error) {
	res, err := c.sendGetSearchSynonym(ctx, params)
	return res, err
}

func (c *Client) sendGetSearchSynonym(ctx context.Context, params GetSearchSynonymParams) (res GetSearchSynonymRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/synonyms/"
	{
		// Encode "synonymId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "synonymId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SynonymId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetSearchSynonymOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSearchSynonymResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSearchSynonyms invokes getSearchSynonyms operation.
//
// List all collection synonyms.
//
// GET /collections/{collectionName}/synonyms
func (c *Client) GetSearchSynonyms(ctx context.Context, params GetSearchSynonymsParams) (GetSearchSynonymsRes, error) {
	res, err := c.sendGetSearchSynonyms(ctx, params)
	return res, err
}

func (c *Client) sendGetSearchSynonyms(ctx context.Context, params GetSearchSynonymsParams) (res GetSearchSynonymsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/synonyms"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetSearchSynonymsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSearchSynonymsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStemmingDictionary invokes getStemmingDictionary operation.
//
// Fetch details of a specific stemming dictionary.
//
// GET /stemming/dictionaries/{dictionaryId}
func (c *Client) GetStemmingDictionary(ctx context.Context, params GetStemmingDictionaryParams) (GetStemmingDictionaryRes, error) {
	res, err := c.sendGetStemmingDictionary(ctx, params)
	return res, err
}

func (c *Client) sendGetStemmingDictionary(ctx context.Context, params GetStemmingDictionaryParams) (res GetStemmingDictionaryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stemming/dictionaries/"
	{
		// Encode "dictionaryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dictionaryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DictionaryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, GetStemmingDictionaryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStemmingDictionaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Health invokes health operation.
//
// Checks if Typesense server is ready to accept requests.
//
// GET /health
func (c *Client) Health(ctx context.Context) (*HealthStatus, error) {
	res, err := c.sendHealth(ctx)
	return res, err
}

func (c *Client) sendHealth(ctx context.Context) (res *HealthStatus, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, HealthOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHealthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ImportDocuments invokes importDocuments operation.
//
// The documents to be imported must be formatted in a newline delimited JSON structure. You can feed
// the output file from a Typesense export operation directly as import.
//
// POST /collections/{collectionName}/documents/import
func (c *Client) ImportDocuments(ctx context.Context, request ImportDocumentsReq, params ImportDocumentsParams) (ImportDocumentsRes, error) {
	res, err := c.sendImportDocuments(ctx, request, params)
	return res, err
}

func (c *Client) sendImportDocuments(ctx context.Context, request ImportDocumentsReq, params ImportDocumentsParams) (res ImportDocumentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/import"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "importDocumentsParameters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "importDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ImportDocumentsParameters.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeImportDocumentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, ImportDocumentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeImportDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ImportStemmingDictionary invokes importStemmingDictionary operation.
//
// Upload a JSONL file containing word mappings to create or update a stemming dictionary.
//
// POST /stemming/dictionaries/import
func (c *Client) ImportStemmingDictionary(ctx context.Context, request string, params ImportStemmingDictionaryParams) (ImportStemmingDictionaryRes, error) {
	res, err := c.sendImportStemmingDictionary(ctx, request, params)
	return res, err
}

func (c *Client) sendImportStemmingDictionary(ctx context.Context, request string, params ImportStemmingDictionaryParams) (res ImportStemmingDictionaryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stemming/dictionaries/import"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeImportStemmingDictionaryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, ImportStemmingDictionaryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeImportStemmingDictionaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IndexDocument invokes indexDocument operation.
//
// A document to be indexed in a given collection must conform to the schema of the collection.
//
// POST /collections/{collectionName}/documents
func (c *Client) IndexDocument(ctx context.Context, request *IndexDocumentReq, params IndexDocumentParams) (IndexDocumentRes, error) {
	res, err := c.sendIndexDocument(ctx, request, params)
	return res, err
}

func (c *Client) sendIndexDocument(ctx context.Context, request *IndexDocumentReq, params IndexDocumentParams) (res IndexDocumentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "action" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "action",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Action.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dirty_values" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dirty_values",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DirtyValues.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIndexDocumentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, IndexDocumentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIndexDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListStemmingDictionaries invokes listStemmingDictionaries operation.
//
// Retrieve a list of all available stemming dictionaries.
//
// GET /stemming/dictionaries
func (c *Client) ListStemmingDictionaries(ctx context.Context) (*ListStemmingDictionariesOK, error) {
	res, err := c.sendListStemmingDictionaries(ctx)
	return res, err
}

func (c *Client) sendListStemmingDictionaries(ctx context.Context) (res *ListStemmingDictionariesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stemming/dictionaries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, ListStemmingDictionariesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListStemmingDictionariesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MultiSearch invokes multiSearch operation.
//
// This is especially useful to avoid round-trip network latencies incurred otherwise if each of
// these requests are sent in separate HTTP requests. You can also use this feature to do a federated
// search across multiple collections in a single HTTP request.
//
// POST /multi_search
func (c *Client) MultiSearch(ctx context.Context, request OptMultiSearchSearchesParameter, params MultiSearchParams) (MultiSearchRes, error) {
	res, err := c.sendMultiSearch(ctx, request, params)
	return res, err
}

func (c *Client) sendMultiSearch(ctx context.Context, request OptMultiSearchSearchesParameter, params MultiSearchParams) (res MultiSearchRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/multi_search"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "multiSearchParameters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "multiSearchParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return params.MultiSearchParameters.EncodeURI(e)
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMultiSearchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, MultiSearchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMultiSearchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveAPIStats invokes retrieveAPIStats operation.
//
// Retrieve the stats about API endpoints.
//
// GET /stats.json
func (c *Client) RetrieveAPIStats(ctx context.Context) (*APIStatsResponse, error) {
	res, err := c.sendRetrieveAPIStats(ctx)
	return res, err
}

func (c *Client) sendRetrieveAPIStats(ctx context.Context) (res *APIStatsResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stats.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveAPIStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveAPIStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveAllConversationModels invokes retrieveAllConversationModels operation.
//
// Retrieve all conversation models.
//
// GET /conversations/models
func (c *Client) RetrieveAllConversationModels(ctx context.Context) ([]ConversationModelSchema, error) {
	res, err := c.sendRetrieveAllConversationModels(ctx)
	return res, err
}

func (c *Client) sendRetrieveAllConversationModels(ctx context.Context) (res []ConversationModelSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/conversations/models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveAllConversationModelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveAllConversationModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveAllNLSearchModels invokes retrieveAllNLSearchModels operation.
//
// Retrieve all NL search models.
//
// GET /nl_search_models
func (c *Client) RetrieveAllNLSearchModels(ctx context.Context) ([]NLSearchModelSchema, error) {
	res, err := c.sendRetrieveAllNLSearchModels(ctx)
	return res, err
}

func (c *Client) sendRetrieveAllNLSearchModels(ctx context.Context) (res []NLSearchModelSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/nl_search_models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveAllNLSearchModelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveAllNLSearchModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveAllPresets invokes retrieveAllPresets operation.
//
// Retrieve the details of all presets.
//
// GET /presets
func (c *Client) RetrieveAllPresets(ctx context.Context) (*PresetsRetrieveSchema, error) {
	res, err := c.sendRetrieveAllPresets(ctx)
	return res, err
}

func (c *Client) sendRetrieveAllPresets(ctx context.Context) (res *PresetsRetrieveSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/presets"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveAllPresetsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveAllPresetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveAnalyticsRule invokes retrieveAnalyticsRule operation.
//
// Retrieve the details of an analytics rule, given it's name.
//
// GET /analytics/rules/{ruleName}
func (c *Client) RetrieveAnalyticsRule(ctx context.Context, params RetrieveAnalyticsRuleParams) (RetrieveAnalyticsRuleRes, error) {
	res, err := c.sendRetrieveAnalyticsRule(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveAnalyticsRule(ctx context.Context, params RetrieveAnalyticsRuleParams) (res RetrieveAnalyticsRuleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/analytics/rules/"
	{
		// Encode "ruleName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveAnalyticsRuleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveAnalyticsRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveAnalyticsRules invokes retrieveAnalyticsRules operation.
//
// Retrieve the details of all analytics rules.
//
// GET /analytics/rules
func (c *Client) RetrieveAnalyticsRules(ctx context.Context) (*AnalyticsRulesRetrieveSchema, error) {
	res, err := c.sendRetrieveAnalyticsRules(ctx)
	return res, err
}

func (c *Client) sendRetrieveAnalyticsRules(ctx context.Context) (res *AnalyticsRulesRetrieveSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/analytics/rules"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveAnalyticsRulesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveAnalyticsRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveConversationModel invokes retrieveConversationModel operation.
//
// Retrieve a conversation model.
//
// GET /conversations/models/{modelId}
func (c *Client) RetrieveConversationModel(ctx context.Context, params RetrieveConversationModelParams) (*ConversationModelSchema, error) {
	res, err := c.sendRetrieveConversationModel(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveConversationModel(ctx context.Context, params RetrieveConversationModelParams) (res *ConversationModelSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/conversations/models/"
	{
		// Encode "modelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "modelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveConversationModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveConversationModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveMetrics invokes retrieveMetrics operation.
//
// Retrieve the metrics.
//
// GET /metrics.json
func (c *Client) RetrieveMetrics(ctx context.Context) error {
	_, err := c.sendRetrieveMetrics(ctx)
	return err
}

func (c *Client) sendRetrieveMetrics(ctx context.Context) (res *RetrieveMetricsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/metrics.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveMetricsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveNLSearchModel invokes retrieveNLSearchModel operation.
//
// Retrieve a specific NL search model by its ID.
//
// GET /nl_search_models/{modelId}
func (c *Client) RetrieveNLSearchModel(ctx context.Context, params RetrieveNLSearchModelParams) (RetrieveNLSearchModelRes, error) {
	res, err := c.sendRetrieveNLSearchModel(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveNLSearchModel(ctx context.Context, params RetrieveNLSearchModelParams) (res RetrieveNLSearchModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/nl_search_models/"
	{
		// Encode "modelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "modelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveNLSearchModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveNLSearchModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrievePreset invokes retrievePreset operation.
//
// Retrieve the details of a preset, given it's name.
//
// GET /presets/{presetId}
func (c *Client) RetrievePreset(ctx context.Context, params RetrievePresetParams) (RetrievePresetRes, error) {
	res, err := c.sendRetrievePreset(ctx, params)
	return res, err
}

func (c *Client) sendRetrievePreset(ctx context.Context, params RetrievePresetParams) (res RetrievePresetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/presets/"
	{
		// Encode "presetId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "presetId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PresetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrievePresetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrievePresetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveStopwordsSet invokes retrieveStopwordsSet operation.
//
// Retrieve the details of a stopwords set, given it's name.
//
// GET /stopwords/{setId}
func (c *Client) RetrieveStopwordsSet(ctx context.Context, params RetrieveStopwordsSetParams) (RetrieveStopwordsSetRes, error) {
	res, err := c.sendRetrieveStopwordsSet(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveStopwordsSet(ctx context.Context, params RetrieveStopwordsSetParams) (res RetrieveStopwordsSetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stopwords/"
	{
		// Encode "setId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "setId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveStopwordsSetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveStopwordsSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveStopwordsSets invokes retrieveStopwordsSets operation.
//
// Retrieve the details of all stopwords sets.
//
// GET /stopwords
func (c *Client) RetrieveStopwordsSets(ctx context.Context) (*StopwordsSetsRetrieveAllSchema, error) {
	res, err := c.sendRetrieveStopwordsSets(ctx)
	return res, err
}

func (c *Client) sendRetrieveStopwordsSets(ctx context.Context) (res *StopwordsSetsRetrieveAllSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stopwords"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, RetrieveStopwordsSetsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveStopwordsSetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchCollection invokes searchCollection operation.
//
// Search for documents in a collection that match the search criteria.
//
// GET /collections/{collectionName}/documents/search
func (c *Client) SearchCollection(ctx context.Context, params SearchCollectionParams) (SearchCollectionRes, error) {
	res, err := c.sendSearchCollection(ctx, params)
	return res, err
}

func (c *Client) sendSearchCollection(ctx context.Context, params SearchCollectionParams) (res SearchCollectionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/search"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "searchParameters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "searchParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return params.SearchParameters.EncodeURI(e)
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, SearchCollectionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchCollectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TakeSnapshot invokes takeSnapshot operation.
//
// Creates a point-in-time snapshot of a Typesense node's state and data in the specified directory.
// You can then backup the snapshot directory that gets created and later restore it as a data
// directory, as needed.
//
// POST /operations/snapshot
func (c *Client) TakeSnapshot(ctx context.Context, params TakeSnapshotParams) (*SuccessStatus, error) {
	res, err := c.sendTakeSnapshot(ctx, params)
	return res, err
}

func (c *Client) sendTakeSnapshot(ctx context.Context, params TakeSnapshotParams) (res *SuccessStatus, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/operations/snapshot"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "snapshot_path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "snapshot_path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SnapshotPath))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, TakeSnapshotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTakeSnapshotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCollection invokes updateCollection operation.
//
// Update a collection's schema to modify the fields and their types.
//
// PATCH /collections/{collectionName}
func (c *Client) UpdateCollection(ctx context.Context, request *CollectionUpdateSchema, params UpdateCollectionParams) (UpdateCollectionRes, error) {
	res, err := c.sendUpdateCollection(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCollection(ctx context.Context, request *CollectionUpdateSchema, params UpdateCollectionParams) (res UpdateCollectionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCollectionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpdateCollectionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateCollectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateConversationModel invokes updateConversationModel operation.
//
// Update a conversation model.
//
// PUT /conversations/models/{modelId}
func (c *Client) UpdateConversationModel(ctx context.Context, request *ConversationModelUpdateSchema, params UpdateConversationModelParams) (*ConversationModelSchema, error) {
	res, err := c.sendUpdateConversationModel(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateConversationModel(ctx context.Context, request *ConversationModelUpdateSchema, params UpdateConversationModelParams) (res *ConversationModelSchema, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/conversations/models/"
	{
		// Encode "modelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "modelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateConversationModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpdateConversationModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateConversationModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDocument invokes updateDocument operation.
//
// Update an individual document from a collection by using its ID. The update can be partial.
//
// PATCH /collections/{collectionName}/documents/{documentId}
func (c *Client) UpdateDocument(ctx context.Context, request *UpdateDocumentReq, params UpdateDocumentParams) (UpdateDocumentRes, error) {
	res, err := c.sendUpdateDocument(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDocument(ctx context.Context, request *UpdateDocumentReq, params UpdateDocumentParams) (res UpdateDocumentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/"
	{
		// Encode "documentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "dirty_values" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dirty_values",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DirtyValues.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDocumentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpdateDocumentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDocuments invokes updateDocuments operation.
//
// The filter_by query parameter is used to filter to specify a condition against which the documents
// are matched. The request body contains the fields that should be updated for any documents that
// match the filter condition. This endpoint is only available if the Typesense server is version `0.
// 25.0.rc12` or later.
//
// PATCH /collections/{collectionName}/documents
func (c *Client) UpdateDocuments(ctx context.Context, request *UpdateDocumentsReq, params UpdateDocumentsParams) (UpdateDocumentsRes, error) {
	res, err := c.sendUpdateDocuments(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDocuments(ctx context.Context, request *UpdateDocumentsReq, params UpdateDocumentsParams) (res UpdateDocumentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "updateDocumentsParameters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "updateDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UpdateDocumentsParameters.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDocumentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpdateDocumentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateNLSearchModel invokes updateNLSearchModel operation.
//
// Update an existing NL search model.
//
// PUT /nl_search_models/{modelId}
func (c *Client) UpdateNLSearchModel(ctx context.Context, request *NLSearchModelCreateSchema, params UpdateNLSearchModelParams) (UpdateNLSearchModelRes, error) {
	res, err := c.sendUpdateNLSearchModel(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateNLSearchModel(ctx context.Context, request *NLSearchModelCreateSchema, params UpdateNLSearchModelParams) (res UpdateNLSearchModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/nl_search_models/"
	{
		// Encode "modelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "modelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateNLSearchModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpdateNLSearchModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateNLSearchModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertAlias invokes upsertAlias operation.
//
// Create or update a collection alias. An alias is a virtual collection name that points to a real
// collection. If you're familiar with symbolic links on Linux, it's very similar to that. Aliases
// are useful when you want to reindex your data in the background on a new collection and switch
// your application to it without any changes to your code.
//
// PUT /aliases/{aliasName}
func (c *Client) UpsertAlias(ctx context.Context, request OptCollectionAliasSchema, params UpsertAliasParams) (UpsertAliasRes, error) {
	res, err := c.sendUpsertAlias(ctx, request, params)
	return res, err
}

func (c *Client) sendUpsertAlias(ctx context.Context, request OptCollectionAliasSchema, params UpsertAliasParams) (res UpsertAliasRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/aliases/"
	{
		// Encode "aliasName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "aliasName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AliasName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertAliasRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpsertAliasOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpsertAliasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertAnalyticsRule invokes upsertAnalyticsRule operation.
//
// Upserts an analytics rule with the given name.
//
// PUT /analytics/rules/{ruleName}
func (c *Client) UpsertAnalyticsRule(ctx context.Context, request *AnalyticsRuleUpsertSchema, params UpsertAnalyticsRuleParams) (UpsertAnalyticsRuleRes, error) {
	res, err := c.sendUpsertAnalyticsRule(ctx, request, params)
	return res, err
}

func (c *Client) sendUpsertAnalyticsRule(ctx context.Context, request *AnalyticsRuleUpsertSchema, params UpsertAnalyticsRuleParams) (res UpsertAnalyticsRuleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/analytics/rules/"
	{
		// Encode "ruleName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertAnalyticsRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpsertAnalyticsRuleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpsertAnalyticsRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertPreset invokes upsertPreset operation.
//
// Create or update an existing preset.
//
// PUT /presets/{presetId}
func (c *Client) UpsertPreset(ctx context.Context, request *PresetUpsertSchema, params UpsertPresetParams) (UpsertPresetRes, error) {
	res, err := c.sendUpsertPreset(ctx, request, params)
	return res, err
}

func (c *Client) sendUpsertPreset(ctx context.Context, request *PresetUpsertSchema, params UpsertPresetParams) (res UpsertPresetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/presets/"
	{
		// Encode "presetId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "presetId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PresetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertPresetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpsertPresetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpsertPresetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertSearchOverride invokes upsertSearchOverride operation.
//
// Create or update an override to promote certain documents over others. Using overrides, you can
// include or exclude specific documents for a given query.
//
// PUT /collections/{collectionName}/overrides/{overrideId}
func (c *Client) UpsertSearchOverride(ctx context.Context, request *SearchOverrideSchema, params UpsertSearchOverrideParams) (UpsertSearchOverrideRes, error) {
	res, err := c.sendUpsertSearchOverride(ctx, request, params)
	return res, err
}

func (c *Client) sendUpsertSearchOverride(ctx context.Context, request *SearchOverrideSchema, params UpsertSearchOverrideParams) (res UpsertSearchOverrideRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/overrides/"
	{
		// Encode "overrideId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "overrideId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OverrideId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertSearchOverrideRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpsertSearchOverrideOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpsertSearchOverrideResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertSearchSynonym invokes upsertSearchSynonym operation.
//
// Create or update a synonym  to define search terms that should be considered equivalent.
//
// PUT /collections/{collectionName}/synonyms/{synonymId}
func (c *Client) UpsertSearchSynonym(ctx context.Context, request *SearchSynonymSchema, params UpsertSearchSynonymParams) (UpsertSearchSynonymRes, error) {
	res, err := c.sendUpsertSearchSynonym(ctx, request, params)
	return res, err
}

func (c *Client) sendUpsertSearchSynonym(ctx context.Context, request *SearchSynonymSchema, params UpsertSearchSynonymParams) (res UpsertSearchSynonymRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/collections/"
	{
		// Encode "collectionName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "collectionName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CollectionName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/synonyms/"
	{
		// Encode "synonymId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "synonymId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SynonymId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertSearchSynonymRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpsertSearchSynonymOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpsertSearchSynonymResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertStopwordsSet invokes upsertStopwordsSet operation.
//
// When an analytics rule is created, we give it a name and describe the type, the source collections
// and the destination collection.
//
// PUT /stopwords/{setId}
func (c *Client) UpsertStopwordsSet(ctx context.Context, request *StopwordsSetUpsertSchema, params UpsertStopwordsSetParams) (UpsertStopwordsSetRes, error) {
	res, err := c.sendUpsertStopwordsSet(ctx, request, params)
	return res, err
}

func (c *Client) sendUpsertStopwordsSet(ctx context.Context, request *StopwordsSetUpsertSchema, params UpsertStopwordsSetParams) (res UpsertStopwordsSetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stopwords/"
	{
		// Encode "setId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "setId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertStopwordsSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, UpsertStopwordsSetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpsertStopwordsSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Vote invokes vote operation.
//
// Triggers a follower node to initiate the raft voting process, which triggers leader re-election.
// The follower node that you run this operation against will become the new leader, once this
// command succeeds.
//
// POST /operations/vote
func (c *Client) Vote(ctx context.Context) (*SuccessStatus, error) {
	res, err := c.sendVote(ctx)
	return res, err
}

func (c *Client) sendVote(ctx context.Context) (res *SuccessStatus, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/operations/vote"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAPIKeyHeader(ctx, VoteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKeyHeader\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVoteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
