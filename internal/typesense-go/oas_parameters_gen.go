// Code generated by ogen, DO NOT EDIT.

package typesense

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// DeleteAliasParams is parameters of deleteAlias operation.
type DeleteAliasParams struct {
	// The name of the alias to delete.
	AliasName string
}

func unpackDeleteAliasParams(packed middleware.Parameters) (params DeleteAliasParams) {
	{
		key := middleware.ParameterKey{
			Name: "aliasName",
			In:   "path",
		}
		params.AliasName = packed[key].(string)
	}
	return params
}

func decodeDeleteAliasParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAliasParams, _ error) {
	// Decode path: aliasName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "aliasName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AliasName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "aliasName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAnalyticsRuleParams is parameters of deleteAnalyticsRule operation.
type DeleteAnalyticsRuleParams struct {
	// The name of the analytics rule to delete.
	RuleName string
}

func unpackDeleteAnalyticsRuleParams(packed middleware.Parameters) (params DeleteAnalyticsRuleParams) {
	{
		key := middleware.ParameterKey{
			Name: "ruleName",
			In:   "path",
		}
		params.RuleName = packed[key].(string)
	}
	return params
}

func decodeDeleteAnalyticsRuleParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAnalyticsRuleParams, _ error) {
	// Decode path: ruleName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ruleName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RuleName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ruleName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteCollectionParams is parameters of deleteCollection operation.
type DeleteCollectionParams struct {
	// The name of the collection to delete.
	CollectionName string
}

func unpackDeleteCollectionParams(packed middleware.Parameters) (params DeleteCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	return params
}

func decodeDeleteCollectionParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteCollectionParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteConversationModelParams is parameters of deleteConversationModel operation.
type DeleteConversationModelParams struct {
	// The id of the conversation model to delete.
	ModelId string
}

func unpackDeleteConversationModelParams(packed middleware.Parameters) (params DeleteConversationModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "modelId",
			In:   "path",
		}
		params.ModelId = packed[key].(string)
	}
	return params
}

func decodeDeleteConversationModelParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteConversationModelParams, _ error) {
	// Decode path: modelId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "modelId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ModelId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "modelId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteDocumentParams is parameters of deleteDocument operation.
type DeleteDocumentParams struct {
	// The name of the collection to search for the document under.
	CollectionName string
	// The Document ID.
	DocumentId string
}

func unpackDeleteDocumentParams(packed middleware.Parameters) (params DeleteDocumentParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "documentId",
			In:   "path",
		}
		params.DocumentId = packed[key].(string)
	}
	return params
}

func decodeDeleteDocumentParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteDocumentParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: documentId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "documentId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DocumentId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "documentId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteDocumentsParams is parameters of deleteDocuments operation.
type DeleteDocumentsParams struct {
	// The name of the collection to delete documents from.
	CollectionName            string
	DeleteDocumentsParameters OptDeleteDocumentsDeleteDocumentsParameters
}

func unpackDeleteDocumentsParams(packed middleware.Parameters) (params DeleteDocumentsParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "deleteDocumentsParameters",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DeleteDocumentsParameters = v.(OptDeleteDocumentsDeleteDocumentsParameters)
		}
	}
	return params
}

func decodeDeleteDocumentsParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteDocumentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: deleteDocumentsParameters.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "deleteDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{Name: "filter_by", Required: true}, {Name: "batch_size", Required: false}, {Name: "ignore_not_found", Required: false}, {Name: "truncate", Required: false}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDeleteDocumentsParametersVal DeleteDocumentsDeleteDocumentsParameters
				if err := func() error {
					return paramsDotDeleteDocumentsParametersVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.DeleteDocumentsParameters.SetTo(paramsDotDeleteDocumentsParametersVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "deleteDocumentsParameters",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteKeyParams is parameters of deleteKey operation.
type DeleteKeyParams struct {
	// The ID of the key to delete.
	KeyId int64
}

func unpackDeleteKeyParams(packed middleware.Parameters) (params DeleteKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "keyId",
			In:   "path",
		}
		params.KeyId = packed[key].(int64)
	}
	return params
}

func decodeDeleteKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteKeyParams, _ error) {
	// Decode path: keyId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "keyId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.KeyId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "keyId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteNLSearchModelParams is parameters of deleteNLSearchModel operation.
type DeleteNLSearchModelParams struct {
	// The ID of the NL search model to delete.
	ModelId string
}

func unpackDeleteNLSearchModelParams(packed middleware.Parameters) (params DeleteNLSearchModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "modelId",
			In:   "path",
		}
		params.ModelId = packed[key].(string)
	}
	return params
}

func decodeDeleteNLSearchModelParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteNLSearchModelParams, _ error) {
	// Decode path: modelId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "modelId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ModelId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "modelId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeletePresetParams is parameters of deletePreset operation.
type DeletePresetParams struct {
	// The ID of the preset to delete.
	PresetId string
}

func unpackDeletePresetParams(packed middleware.Parameters) (params DeletePresetParams) {
	{
		key := middleware.ParameterKey{
			Name: "presetId",
			In:   "path",
		}
		params.PresetId = packed[key].(string)
	}
	return params
}

func decodeDeletePresetParams(args [1]string, argsEscaped bool, r *http.Request) (params DeletePresetParams, _ error) {
	// Decode path: presetId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "presetId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PresetId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "presetId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteSearchOverrideParams is parameters of deleteSearchOverride operation.
type DeleteSearchOverrideParams struct {
	// The name of the collection.
	CollectionName string
	// The ID of the search override to delete.
	OverrideId string
}

func unpackDeleteSearchOverrideParams(packed middleware.Parameters) (params DeleteSearchOverrideParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "overrideId",
			In:   "path",
		}
		params.OverrideId = packed[key].(string)
	}
	return params
}

func decodeDeleteSearchOverrideParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteSearchOverrideParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: overrideId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "overrideId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.OverrideId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "overrideId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteSearchSynonymParams is parameters of deleteSearchSynonym operation.
type DeleteSearchSynonymParams struct {
	// The name of the collection.
	CollectionName string
	// The ID of the search synonym to delete.
	SynonymId string
}

func unpackDeleteSearchSynonymParams(packed middleware.Parameters) (params DeleteSearchSynonymParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "synonymId",
			In:   "path",
		}
		params.SynonymId = packed[key].(string)
	}
	return params
}

func decodeDeleteSearchSynonymParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteSearchSynonymParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: synonymId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "synonymId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SynonymId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "synonymId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteStopwordsSetParams is parameters of deleteStopwordsSet operation.
type DeleteStopwordsSetParams struct {
	// The ID of the stopwords set to delete.
	SetId string
}

func unpackDeleteStopwordsSetParams(packed middleware.Parameters) (params DeleteStopwordsSetParams) {
	{
		key := middleware.ParameterKey{
			Name: "setId",
			In:   "path",
		}
		params.SetId = packed[key].(string)
	}
	return params
}

func decodeDeleteStopwordsSetParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteStopwordsSetParams, _ error) {
	// Decode path: setId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "setId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SetId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "setId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ExportDocumentsParams is parameters of exportDocuments operation.
type ExportDocumentsParams struct {
	// The name of the collection.
	CollectionName            string
	ExportDocumentsParameters OptExportDocumentsExportDocumentsParameters
}

func unpackExportDocumentsParams(packed middleware.Parameters) (params ExportDocumentsParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "exportDocumentsParameters",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ExportDocumentsParameters = v.(OptExportDocumentsExportDocumentsParameters)
		}
	}
	return params
}

func decodeExportDocumentsParams(args [1]string, argsEscaped bool, r *http.Request) (params ExportDocumentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: exportDocumentsParameters.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exportDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{Name: "filter_by", Required: false}, {Name: "include_fields", Required: false}, {Name: "exclude_fields", Required: false}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExportDocumentsParametersVal ExportDocumentsExportDocumentsParameters
				if err := func() error {
					return paramsDotExportDocumentsParametersVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.ExportDocumentsParameters.SetTo(paramsDotExportDocumentsParametersVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "exportDocumentsParameters",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAliasParams is parameters of getAlias operation.
type GetAliasParams struct {
	// The name of the alias to retrieve.
	AliasName string
}

func unpackGetAliasParams(packed middleware.Parameters) (params GetAliasParams) {
	{
		key := middleware.ParameterKey{
			Name: "aliasName",
			In:   "path",
		}
		params.AliasName = packed[key].(string)
	}
	return params
}

func decodeGetAliasParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAliasParams, _ error) {
	// Decode path: aliasName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "aliasName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AliasName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "aliasName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCollectionParams is parameters of getCollection operation.
type GetCollectionParams struct {
	// The name of the collection to retrieve.
	CollectionName string
}

func unpackGetCollectionParams(packed middleware.Parameters) (params GetCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	return params
}

func decodeGetCollectionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCollectionParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCollectionsParams is parameters of getCollections operation.
type GetCollectionsParams struct {
	GetCollectionsParameters OptGetCollectionsGetCollectionsParameters
}

func unpackGetCollectionsParams(packed middleware.Parameters) (params GetCollectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "getCollectionsParameters",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.GetCollectionsParameters = v.(OptGetCollectionsGetCollectionsParameters)
		}
	}
	return params
}

func decodeGetCollectionsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetCollectionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: getCollectionsParameters.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "getCollectionsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{Name: "exclude_fields", Required: false}, {Name: "limit", Required: false}, {Name: "offset", Required: false}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotGetCollectionsParametersVal GetCollectionsGetCollectionsParameters
				if err := func() error {
					return paramsDotGetCollectionsParametersVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.GetCollectionsParameters.SetTo(paramsDotGetCollectionsParametersVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "getCollectionsParameters",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDocumentParams is parameters of getDocument operation.
type GetDocumentParams struct {
	// The name of the collection to search for the document under.
	CollectionName string
	// The Document ID.
	DocumentId string
}

func unpackGetDocumentParams(packed middleware.Parameters) (params GetDocumentParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "documentId",
			In:   "path",
		}
		params.DocumentId = packed[key].(string)
	}
	return params
}

func decodeGetDocumentParams(args [2]string, argsEscaped bool, r *http.Request) (params GetDocumentParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: documentId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "documentId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DocumentId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "documentId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetKeyParams is parameters of getKey operation.
type GetKeyParams struct {
	// The ID of the key to retrieve.
	KeyId int64
}

func unpackGetKeyParams(packed middleware.Parameters) (params GetKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "keyId",
			In:   "path",
		}
		params.KeyId = packed[key].(int64)
	}
	return params
}

func decodeGetKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params GetKeyParams, _ error) {
	// Decode path: keyId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "keyId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.KeyId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "keyId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSearchOverrideParams is parameters of getSearchOverride operation.
type GetSearchOverrideParams struct {
	// The name of the collection.
	CollectionName string
	// The id of the search override.
	OverrideId string
}

func unpackGetSearchOverrideParams(packed middleware.Parameters) (params GetSearchOverrideParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "overrideId",
			In:   "path",
		}
		params.OverrideId = packed[key].(string)
	}
	return params
}

func decodeGetSearchOverrideParams(args [2]string, argsEscaped bool, r *http.Request) (params GetSearchOverrideParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: overrideId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "overrideId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.OverrideId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "overrideId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSearchOverridesParams is parameters of getSearchOverrides operation.
type GetSearchOverridesParams struct {
	// The name of the collection.
	CollectionName string
}

func unpackGetSearchOverridesParams(packed middleware.Parameters) (params GetSearchOverridesParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	return params
}

func decodeGetSearchOverridesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSearchOverridesParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSearchSynonymParams is parameters of getSearchSynonym operation.
type GetSearchSynonymParams struct {
	// The name of the collection.
	CollectionName string
	// The id of the search synonym.
	SynonymId string
}

func unpackGetSearchSynonymParams(packed middleware.Parameters) (params GetSearchSynonymParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "synonymId",
			In:   "path",
		}
		params.SynonymId = packed[key].(string)
	}
	return params
}

func decodeGetSearchSynonymParams(args [2]string, argsEscaped bool, r *http.Request) (params GetSearchSynonymParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: synonymId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "synonymId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SynonymId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "synonymId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSearchSynonymsParams is parameters of getSearchSynonyms operation.
type GetSearchSynonymsParams struct {
	// The name of the collection.
	CollectionName string
}

func unpackGetSearchSynonymsParams(packed middleware.Parameters) (params GetSearchSynonymsParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	return params
}

func decodeGetSearchSynonymsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSearchSynonymsParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetStemmingDictionaryParams is parameters of getStemmingDictionary operation.
type GetStemmingDictionaryParams struct {
	// The ID of the dictionary to retrieve.
	DictionaryId string
}

func unpackGetStemmingDictionaryParams(packed middleware.Parameters) (params GetStemmingDictionaryParams) {
	{
		key := middleware.ParameterKey{
			Name: "dictionaryId",
			In:   "path",
		}
		params.DictionaryId = packed[key].(string)
	}
	return params
}

func decodeGetStemmingDictionaryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetStemmingDictionaryParams, _ error) {
	// Decode path: dictionaryId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dictionaryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DictionaryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dictionaryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ImportDocumentsParams is parameters of importDocuments operation.
type ImportDocumentsParams struct {
	// The name of the collection.
	CollectionName            string
	ImportDocumentsParameters OptImportDocumentsImportDocumentsParameters
}

func unpackImportDocumentsParams(packed middleware.Parameters) (params ImportDocumentsParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "importDocumentsParameters",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ImportDocumentsParameters = v.(OptImportDocumentsImportDocumentsParameters)
		}
	}
	return params
}

func decodeImportDocumentsParams(args [1]string, argsEscaped bool, r *http.Request) (params ImportDocumentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: importDocumentsParameters.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "importDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{Name: "batch_size", Required: false}, {Name: "return_id", Required: false}, {Name: "remote_embedding_batch_size", Required: false}, {Name: "return_doc", Required: false}, {Name: "action", Required: false}, {Name: "dirty_values", Required: false}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotImportDocumentsParametersVal ImportDocumentsImportDocumentsParameters
				if err := func() error {
					return paramsDotImportDocumentsParametersVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.ImportDocumentsParameters.SetTo(paramsDotImportDocumentsParametersVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ImportDocumentsParameters.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "importDocumentsParameters",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ImportStemmingDictionaryParams is parameters of importStemmingDictionary operation.
type ImportStemmingDictionaryParams struct {
	// The ID to assign to the dictionary.
	ID string
}

func unpackImportStemmingDictionaryParams(packed middleware.Parameters) (params ImportStemmingDictionaryParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "query",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeImportStemmingDictionaryParams(args [0]string, argsEscaped bool, r *http.Request) (params ImportStemmingDictionaryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// IndexDocumentParams is parameters of indexDocument operation.
type IndexDocumentParams struct {
	// The name of the collection to add the document to.
	CollectionName string
	// Additional action to perform.
	Action OptIndexAction
	// Dealing with Dirty Data.
	DirtyValues OptDirtyValues
}

func unpackIndexDocumentParams(packed middleware.Parameters) (params IndexDocumentParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "action",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Action = v.(OptIndexAction)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "dirty_values",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DirtyValues = v.(OptDirtyValues)
		}
	}
	return params
}

func decodeIndexDocumentParams(args [1]string, argsEscaped bool, r *http.Request) (params IndexDocumentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: action.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "action",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotActionVal IndexAction
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotActionVal = IndexAction(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Action.SetTo(paramsDotActionVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Action.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "action",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: dirty_values.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "dirty_values",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirtyValuesVal DirtyValues
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirtyValuesVal = DirtyValues(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DirtyValues.SetTo(paramsDotDirtyValuesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.DirtyValues.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dirty_values",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// MultiSearchParams is parameters of multiSearch operation.
type MultiSearchParams struct {
	MultiSearchParameters MultiSearchParameters
}

func unpackMultiSearchParams(packed middleware.Parameters) (params MultiSearchParams) {
	{
		key := middleware.ParameterKey{
			Name: "multiSearchParameters",
			In:   "query",
		}
		params.MultiSearchParameters = packed[key].(MultiSearchParameters)
	}
	return params
}

func decodeMultiSearchParams(args [0]string, argsEscaped bool, r *http.Request) (params MultiSearchParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: multiSearchParameters.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "multiSearchParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{Name: "q", Required: false}, {Name: "query_by", Required: false}, {Name: "query_by_weights", Required: false}, {Name: "text_match_type", Required: false}, {Name: "prefix", Required: false}, {Name: "infix", Required: false}, {Name: "max_extra_prefix", Required: false}, {Name: "max_extra_suffix", Required: false}, {Name: "filter_by", Required: false}, {Name: "sort_by", Required: false}, {Name: "facet_by", Required: false}, {Name: "max_facet_values", Required: false}, {Name: "facet_query", Required: false}, {Name: "num_typos", Required: false}, {Name: "page", Required: false}, {Name: "per_page", Required: false}, {Name: "limit", Required: false}, {Name: "offset", Required: false}, {Name: "group_by", Required: false}, {Name: "group_limit", Required: false}, {Name: "group_missing_values", Required: false}, {Name: "include_fields", Required: false}, {Name: "exclude_fields", Required: false}, {Name: "highlight_full_fields", Required: false}, {Name: "highlight_affix_num_tokens", Required: false}, {Name: "highlight_start_tag", Required: false}, {Name: "highlight_end_tag", Required: false}, {Name: "snippet_threshold", Required: false}, {Name: "drop_tokens_threshold", Required: false}, {Name: "drop_tokens_mode", Required: false}, {Name: "typo_tokens_threshold", Required: false}, {Name: "enable_typos_for_alpha_numerical_tokens", Required: false}, {Name: "filter_curated_hits", Required: false}, {Name: "enable_synonyms", Required: false}, {Name: "synonym_prefix", Required: false}, {Name: "synonym_num_typos", Required: false}, {Name: "pinned_hits", Required: false}, {Name: "hidden_hits", Required: false}, {Name: "override_tags", Required: false}, {Name: "highlight_fields", Required: false}, {Name: "pre_segmented_query", Required: false}, {Name: "preset", Required: false}, {Name: "enable_overrides", Required: false}, {Name: "prioritize_exact_match", Required: false}, {Name: "prioritize_token_position", Required: false}, {Name: "prioritize_num_matching_fields", Required: false}, {Name: "enable_typos_for_numerical_tokens", Required: false}, {Name: "exhaustive_search", Required: false}, {Name: "search_cutoff_ms", Required: false}, {Name: "use_cache", Required: false}, {Name: "cache_ttl", Required: false}, {Name: "min_len_1typo", Required: false}, {Name: "min_len_2typo", Required: false}, {Name: "vector_query", Required: false}, {Name: "remote_embedding_timeout_ms", Required: false}, {Name: "remote_embedding_num_tries", Required: false}, {Name: "facet_strategy", Required: false}, {Name: "stopwords", Required: false}, {Name: "facet_return_parent", Required: false}, {Name: "voice_query", Required: false}, {Name: "conversation", Required: false}, {Name: "conversation_model_id", Required: false}, {Name: "conversation_id", Required: false}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return params.MultiSearchParameters.DecodeURI(d)
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := params.MultiSearchParameters.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "multiSearchParameters",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// RetrieveAnalyticsRuleParams is parameters of retrieveAnalyticsRule operation.
type RetrieveAnalyticsRuleParams struct {
	// The name of the analytics rule to retrieve.
	RuleName string
}

func unpackRetrieveAnalyticsRuleParams(packed middleware.Parameters) (params RetrieveAnalyticsRuleParams) {
	{
		key := middleware.ParameterKey{
			Name: "ruleName",
			In:   "path",
		}
		params.RuleName = packed[key].(string)
	}
	return params
}

func decodeRetrieveAnalyticsRuleParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrieveAnalyticsRuleParams, _ error) {
	// Decode path: ruleName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ruleName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RuleName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ruleName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrieveConversationModelParams is parameters of retrieveConversationModel operation.
type RetrieveConversationModelParams struct {
	// The id of the conversation model to retrieve.
	ModelId string
}

func unpackRetrieveConversationModelParams(packed middleware.Parameters) (params RetrieveConversationModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "modelId",
			In:   "path",
		}
		params.ModelId = packed[key].(string)
	}
	return params
}

func decodeRetrieveConversationModelParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrieveConversationModelParams, _ error) {
	// Decode path: modelId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "modelId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ModelId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "modelId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrieveNLSearchModelParams is parameters of retrieveNLSearchModel operation.
type RetrieveNLSearchModelParams struct {
	// The ID of the NL search model to retrieve.
	ModelId string
}

func unpackRetrieveNLSearchModelParams(packed middleware.Parameters) (params RetrieveNLSearchModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "modelId",
			In:   "path",
		}
		params.ModelId = packed[key].(string)
	}
	return params
}

func decodeRetrieveNLSearchModelParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrieveNLSearchModelParams, _ error) {
	// Decode path: modelId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "modelId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ModelId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "modelId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrievePresetParams is parameters of retrievePreset operation.
type RetrievePresetParams struct {
	// The ID of the preset to retrieve.
	PresetId string
}

func unpackRetrievePresetParams(packed middleware.Parameters) (params RetrievePresetParams) {
	{
		key := middleware.ParameterKey{
			Name: "presetId",
			In:   "path",
		}
		params.PresetId = packed[key].(string)
	}
	return params
}

func decodeRetrievePresetParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrievePresetParams, _ error) {
	// Decode path: presetId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "presetId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PresetId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "presetId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrieveStopwordsSetParams is parameters of retrieveStopwordsSet operation.
type RetrieveStopwordsSetParams struct {
	// The ID of the stopwords set to retrieve.
	SetId string
}

func unpackRetrieveStopwordsSetParams(packed middleware.Parameters) (params RetrieveStopwordsSetParams) {
	{
		key := middleware.ParameterKey{
			Name: "setId",
			In:   "path",
		}
		params.SetId = packed[key].(string)
	}
	return params
}

func decodeRetrieveStopwordsSetParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrieveStopwordsSetParams, _ error) {
	// Decode path: setId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "setId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SetId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "setId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchCollectionParams is parameters of searchCollection operation.
type SearchCollectionParams struct {
	// The name of the collection to search for the document under.
	CollectionName   string
	SearchParameters SearchParameters
}

func unpackSearchCollectionParams(packed middleware.Parameters) (params SearchCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "searchParameters",
			In:   "query",
		}
		params.SearchParameters = packed[key].(SearchParameters)
	}
	return params
}

func decodeSearchCollectionParams(args [1]string, argsEscaped bool, r *http.Request) (params SearchCollectionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: searchParameters.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "searchParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{Name: "q", Required: false}, {Name: "query_by", Required: false}, {Name: "nl_query", Required: false}, {Name: "nl_model_id", Required: false}, {Name: "query_by_weights", Required: false}, {Name: "text_match_type", Required: false}, {Name: "prefix", Required: false}, {Name: "infix", Required: false}, {Name: "max_extra_prefix", Required: false}, {Name: "max_extra_suffix", Required: false}, {Name: "filter_by", Required: false}, {Name: "max_filter_by_candidates", Required: false}, {Name: "sort_by", Required: false}, {Name: "facet_by", Required: false}, {Name: "max_facet_values", Required: false}, {Name: "facet_query", Required: false}, {Name: "num_typos", Required: false}, {Name: "page", Required: false}, {Name: "per_page", Required: false}, {Name: "limit", Required: false}, {Name: "offset", Required: false}, {Name: "group_by", Required: false}, {Name: "group_limit", Required: false}, {Name: "group_missing_values", Required: false}, {Name: "include_fields", Required: false}, {Name: "exclude_fields", Required: false}, {Name: "highlight_full_fields", Required: false}, {Name: "highlight_affix_num_tokens", Required: false}, {Name: "highlight_start_tag", Required: false}, {Name: "highlight_end_tag", Required: false}, {Name: "enable_highlight_v1", Required: false}, {Name: "snippet_threshold", Required: false}, {Name: "drop_tokens_threshold", Required: false}, {Name: "drop_tokens_mode", Required: false}, {Name: "typo_tokens_threshold", Required: false}, {Name: "enable_typos_for_alpha_numerical_tokens", Required: false}, {Name: "filter_curated_hits", Required: false}, {Name: "enable_synonyms", Required: false}, {Name: "synonym_prefix", Required: false}, {Name: "synonym_num_typos", Required: false}, {Name: "pinned_hits", Required: false}, {Name: "hidden_hits", Required: false}, {Name: "override_tags", Required: false}, {Name: "highlight_fields", Required: false}, {Name: "split_join_tokens", Required: false}, {Name: "pre_segmented_query", Required: false}, {Name: "preset", Required: false}, {Name: "enable_overrides", Required: false}, {Name: "prioritize_exact_match", Required: false}, {Name: "max_candidates", Required: false}, {Name: "prioritize_token_position", Required: false}, {Name: "prioritize_num_matching_fields", Required: false}, {Name: "enable_typos_for_numerical_tokens", Required: false}, {Name: "exhaustive_search", Required: false}, {Name: "search_cutoff_ms", Required: false}, {Name: "use_cache", Required: false}, {Name: "cache_ttl", Required: false}, {Name: "min_len_1typo", Required: false}, {Name: "min_len_2typo", Required: false}, {Name: "vector_query", Required: false}, {Name: "remote_embedding_timeout_ms", Required: false}, {Name: "remote_embedding_num_tries", Required: false}, {Name: "facet_strategy", Required: false}, {Name: "stopwords", Required: false}, {Name: "facet_return_parent", Required: false}, {Name: "voice_query", Required: false}, {Name: "conversation", Required: false}, {Name: "conversation_model_id", Required: false}, {Name: "conversation_id", Required: false}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return params.SearchParameters.DecodeURI(d)
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := params.SearchParameters.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "searchParameters",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// TakeSnapshotParams is parameters of takeSnapshot operation.
type TakeSnapshotParams struct {
	// The directory on the server where the snapshot should be saved.
	SnapshotPath string
}

func unpackTakeSnapshotParams(packed middleware.Parameters) (params TakeSnapshotParams) {
	{
		key := middleware.ParameterKey{
			Name: "snapshot_path",
			In:   "query",
		}
		params.SnapshotPath = packed[key].(string)
	}
	return params
}

func decodeTakeSnapshotParams(args [0]string, argsEscaped bool, r *http.Request) (params TakeSnapshotParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: snapshot_path.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "snapshot_path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SnapshotPath = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "snapshot_path",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateCollectionParams is parameters of updateCollection operation.
type UpdateCollectionParams struct {
	// The name of the collection to update.
	CollectionName string
}

func unpackUpdateCollectionParams(packed middleware.Parameters) (params UpdateCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	return params
}

func decodeUpdateCollectionParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateCollectionParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateConversationModelParams is parameters of updateConversationModel operation.
type UpdateConversationModelParams struct {
	// The id of the conversation model to update.
	ModelId string
}

func unpackUpdateConversationModelParams(packed middleware.Parameters) (params UpdateConversationModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "modelId",
			In:   "path",
		}
		params.ModelId = packed[key].(string)
	}
	return params
}

func decodeUpdateConversationModelParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateConversationModelParams, _ error) {
	// Decode path: modelId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "modelId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ModelId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "modelId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateDocumentParams is parameters of updateDocument operation.
type UpdateDocumentParams struct {
	// The name of the collection to search for the document under.
	CollectionName string
	// The Document ID.
	DocumentId string
	// Dealing with Dirty Data.
	DirtyValues OptDirtyValues
}

func unpackUpdateDocumentParams(packed middleware.Parameters) (params UpdateDocumentParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "documentId",
			In:   "path",
		}
		params.DocumentId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "dirty_values",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DirtyValues = v.(OptDirtyValues)
		}
	}
	return params
}

func decodeUpdateDocumentParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateDocumentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: documentId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "documentId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DocumentId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "documentId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: dirty_values.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "dirty_values",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirtyValuesVal DirtyValues
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirtyValuesVal = DirtyValues(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DirtyValues.SetTo(paramsDotDirtyValuesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.DirtyValues.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dirty_values",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateDocumentsParams is parameters of updateDocuments operation.
type UpdateDocumentsParams struct {
	// The name of the collection to update documents in.
	CollectionName            string
	UpdateDocumentsParameters OptUpdateDocumentsUpdateDocumentsParameters
}

func unpackUpdateDocumentsParams(packed middleware.Parameters) (params UpdateDocumentsParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "updateDocumentsParameters",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UpdateDocumentsParameters = v.(OptUpdateDocumentsUpdateDocumentsParameters)
		}
	}
	return params
}

func decodeUpdateDocumentsParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateDocumentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: updateDocumentsParameters.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "updateDocumentsParameters",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{Name: "filter_by", Required: false}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUpdateDocumentsParametersVal UpdateDocumentsUpdateDocumentsParameters
				if err := func() error {
					return paramsDotUpdateDocumentsParametersVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.UpdateDocumentsParameters.SetTo(paramsDotUpdateDocumentsParametersVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "updateDocumentsParameters",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateNLSearchModelParams is parameters of updateNLSearchModel operation.
type UpdateNLSearchModelParams struct {
	// The ID of the NL search model to update.
	ModelId string
}

func unpackUpdateNLSearchModelParams(packed middleware.Parameters) (params UpdateNLSearchModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "modelId",
			In:   "path",
		}
		params.ModelId = packed[key].(string)
	}
	return params
}

func decodeUpdateNLSearchModelParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateNLSearchModelParams, _ error) {
	// Decode path: modelId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "modelId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ModelId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "modelId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpsertAliasParams is parameters of upsertAlias operation.
type UpsertAliasParams struct {
	// The name of the alias to create/update.
	AliasName string
}

func unpackUpsertAliasParams(packed middleware.Parameters) (params UpsertAliasParams) {
	{
		key := middleware.ParameterKey{
			Name: "aliasName",
			In:   "path",
		}
		params.AliasName = packed[key].(string)
	}
	return params
}

func decodeUpsertAliasParams(args [1]string, argsEscaped bool, r *http.Request) (params UpsertAliasParams, _ error) {
	// Decode path: aliasName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "aliasName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AliasName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "aliasName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpsertAnalyticsRuleParams is parameters of upsertAnalyticsRule operation.
type UpsertAnalyticsRuleParams struct {
	// The name of the analytics rule to upsert.
	RuleName string
}

func unpackUpsertAnalyticsRuleParams(packed middleware.Parameters) (params UpsertAnalyticsRuleParams) {
	{
		key := middleware.ParameterKey{
			Name: "ruleName",
			In:   "path",
		}
		params.RuleName = packed[key].(string)
	}
	return params
}

func decodeUpsertAnalyticsRuleParams(args [1]string, argsEscaped bool, r *http.Request) (params UpsertAnalyticsRuleParams, _ error) {
	// Decode path: ruleName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ruleName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RuleName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ruleName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpsertPresetParams is parameters of upsertPreset operation.
type UpsertPresetParams struct {
	// The name of the preset set to upsert.
	PresetId string
}

func unpackUpsertPresetParams(packed middleware.Parameters) (params UpsertPresetParams) {
	{
		key := middleware.ParameterKey{
			Name: "presetId",
			In:   "path",
		}
		params.PresetId = packed[key].(string)
	}
	return params
}

func decodeUpsertPresetParams(args [1]string, argsEscaped bool, r *http.Request) (params UpsertPresetParams, _ error) {
	// Decode path: presetId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "presetId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PresetId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "presetId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpsertSearchOverrideParams is parameters of upsertSearchOverride operation.
type UpsertSearchOverrideParams struct {
	// The name of the collection.
	CollectionName string
	// The ID of the search override to create/update.
	OverrideId string
}

func unpackUpsertSearchOverrideParams(packed middleware.Parameters) (params UpsertSearchOverrideParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "overrideId",
			In:   "path",
		}
		params.OverrideId = packed[key].(string)
	}
	return params
}

func decodeUpsertSearchOverrideParams(args [2]string, argsEscaped bool, r *http.Request) (params UpsertSearchOverrideParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: overrideId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "overrideId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.OverrideId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "overrideId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpsertSearchSynonymParams is parameters of upsertSearchSynonym operation.
type UpsertSearchSynonymParams struct {
	// The name of the collection.
	CollectionName string
	// The ID of the search synonym to create/update.
	SynonymId string
}

func unpackUpsertSearchSynonymParams(packed middleware.Parameters) (params UpsertSearchSynonymParams) {
	{
		key := middleware.ParameterKey{
			Name: "collectionName",
			In:   "path",
		}
		params.CollectionName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "synonymId",
			In:   "path",
		}
		params.SynonymId = packed[key].(string)
	}
	return params
}

func decodeUpsertSearchSynonymParams(args [2]string, argsEscaped bool, r *http.Request) (params UpsertSearchSynonymParams, _ error) {
	// Decode path: collectionName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "collectionName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CollectionName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collectionName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: synonymId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "synonymId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SynonymId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "synonymId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpsertStopwordsSetParams is parameters of upsertStopwordsSet operation.
type UpsertStopwordsSetParams struct {
	// The ID of the stopwords set to upsert.
	SetId string
}

func unpackUpsertStopwordsSetParams(packed middleware.Parameters) (params UpsertStopwordsSetParams) {
	{
		key := middleware.ParameterKey{
			Name: "setId",
			In:   "path",
		}
		params.SetId = packed[key].(string)
	}
	return params
}

func decodeUpsertStopwordsSetParams(args [1]string, argsEscaped bool, r *http.Request) (params UpsertStopwordsSetParams, _ error) {
	// Decode path: setId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "setId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SetId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "setId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
