// Code generated by ogen, DO NOT EDIT.

package typesense

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *APIStatsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIStatsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.DeleteLatencyMs.Set {
			e.FieldStart("delete_latency_ms")
			s.DeleteLatencyMs.Encode(e)
		}
	}
	{
		if s.DeleteRequestsPerSecond.Set {
			e.FieldStart("delete_requests_per_second")
			s.DeleteRequestsPerSecond.Encode(e)
		}
	}
	{
		if s.ImportLatencyMs.Set {
			e.FieldStart("import_latency_ms")
			s.ImportLatencyMs.Encode(e)
		}
	}
	{
		if s.ImportRequestsPerSecond.Set {
			e.FieldStart("import_requests_per_second")
			s.ImportRequestsPerSecond.Encode(e)
		}
	}
	{
		if s.LatencyMs != nil {
			e.FieldStart("latency_ms")
			s.LatencyMs.Encode(e)
		}
	}
	{
		if s.OverloadedRequestsPerSecond.Set {
			e.FieldStart("overloaded_requests_per_second")
			s.OverloadedRequestsPerSecond.Encode(e)
		}
	}
	{
		if s.PendingWriteBatches.Set {
			e.FieldStart("pending_write_batches")
			s.PendingWriteBatches.Encode(e)
		}
	}
	{
		if s.RequestsPerSecond != nil {
			e.FieldStart("requests_per_second")
			s.RequestsPerSecond.Encode(e)
		}
	}
	{
		if s.SearchLatencyMs.Set {
			e.FieldStart("search_latency_ms")
			s.SearchLatencyMs.Encode(e)
		}
	}
	{
		if s.SearchRequestsPerSecond.Set {
			e.FieldStart("search_requests_per_second")
			s.SearchRequestsPerSecond.Encode(e)
		}
	}
	{
		if s.TotalRequestsPerSecond.Set {
			e.FieldStart("total_requests_per_second")
			s.TotalRequestsPerSecond.Encode(e)
		}
	}
	{
		if s.WriteLatencyMs.Set {
			e.FieldStart("write_latency_ms")
			s.WriteLatencyMs.Encode(e)
		}
	}
	{
		if s.WriteRequestsPerSecond.Set {
			e.FieldStart("write_requests_per_second")
			s.WriteRequestsPerSecond.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIStatsResponse = [13]string{
	0:  "delete_latency_ms",
	1:  "delete_requests_per_second",
	2:  "import_latency_ms",
	3:  "import_requests_per_second",
	4:  "latency_ms",
	5:  "overloaded_requests_per_second",
	6:  "pending_write_batches",
	7:  "requests_per_second",
	8:  "search_latency_ms",
	9:  "search_requests_per_second",
	10: "total_requests_per_second",
	11: "write_latency_ms",
	12: "write_requests_per_second",
}

// Decode decodes APIStatsResponse from json.
func (s *APIStatsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIStatsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "delete_latency_ms":
			if err := func() error {
				s.DeleteLatencyMs.Reset()
				if err := s.DeleteLatencyMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_latency_ms\"")
			}
		case "delete_requests_per_second":
			if err := func() error {
				s.DeleteRequestsPerSecond.Reset()
				if err := s.DeleteRequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_requests_per_second\"")
			}
		case "import_latency_ms":
			if err := func() error {
				s.ImportLatencyMs.Reset()
				if err := s.ImportLatencyMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_latency_ms\"")
			}
		case "import_requests_per_second":
			if err := func() error {
				s.ImportRequestsPerSecond.Reset()
				if err := s.ImportRequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_requests_per_second\"")
			}
		case "latency_ms":
			if err := func() error {
				s.LatencyMs = nil
				var elem APIStatsResponseLatencyMs
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.LatencyMs = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latency_ms\"")
			}
		case "overloaded_requests_per_second":
			if err := func() error {
				s.OverloadedRequestsPerSecond.Reset()
				if err := s.OverloadedRequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overloaded_requests_per_second\"")
			}
		case "pending_write_batches":
			if err := func() error {
				s.PendingWriteBatches.Reset()
				if err := s.PendingWriteBatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_write_batches\"")
			}
		case "requests_per_second":
			if err := func() error {
				s.RequestsPerSecond = nil
				var elem APIStatsResponseRequestsPerSecond
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RequestsPerSecond = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_second\"")
			}
		case "search_latency_ms":
			if err := func() error {
				s.SearchLatencyMs.Reset()
				if err := s.SearchLatencyMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_latency_ms\"")
			}
		case "search_requests_per_second":
			if err := func() error {
				s.SearchRequestsPerSecond.Reset()
				if err := s.SearchRequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_requests_per_second\"")
			}
		case "total_requests_per_second":
			if err := func() error {
				s.TotalRequestsPerSecond.Reset()
				if err := s.TotalRequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_requests_per_second\"")
			}
		case "write_latency_ms":
			if err := func() error {
				s.WriteLatencyMs.Reset()
				if err := s.WriteLatencyMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"write_latency_ms\"")
			}
		case "write_requests_per_second":
			if err := func() error {
				s.WriteRequestsPerSecond.Reset()
				if err := s.WriteRequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"write_requests_per_second\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIStatsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIStatsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIStatsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIStatsResponseLatencyMs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIStatsResponseLatencyMs) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAPIStatsResponseLatencyMs = [0]string{}

// Decode decodes APIStatsResponseLatencyMs from json.
func (s *APIStatsResponseLatencyMs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIStatsResponseLatencyMs to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode APIStatsResponseLatencyMs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIStatsResponseLatencyMs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIStatsResponseLatencyMs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIStatsResponseRequestsPerSecond) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIStatsResponseRequestsPerSecond) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAPIStatsResponseRequestsPerSecond = [0]string{}

// Decode decodes APIStatsResponseRequestsPerSecond from json.
func (s *APIStatsResponseRequestsPerSecond) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIStatsResponseRequestsPerSecond to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode APIStatsResponseRequestsPerSecond")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIStatsResponseRequestsPerSecond) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIStatsResponseRequestsPerSecond) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsEventCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsEventCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfAnalyticsEventCreateResponse = [1]string{
	0: "ok",
}

// Decode decodes AnalyticsEventCreateResponse from json.
func (s *AnalyticsEventCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsEventCreateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ok":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsEventCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsEventCreateResponse) {
					name = jsonFieldsNameOfAnalyticsEventCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsEventCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsEventCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsEventCreateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsEventCreateSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfAnalyticsEventCreateSchema = [3]string{
	0: "type",
	1: "name",
	2: "data",
}

// Decode decodes AnalyticsEventCreateSchema from json.
func (s *AnalyticsEventCreateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsEventCreateSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsEventCreateSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsEventCreateSchema) {
					name = jsonFieldsNameOfAnalyticsEventCreateSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsEventCreateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsEventCreateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsEventCreateSchemaData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsEventCreateSchemaData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAnalyticsEventCreateSchemaData = [0]string{}

// Decode decodes AnalyticsEventCreateSchemaData from json.
func (s *AnalyticsEventCreateSchemaData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsEventCreateSchemaData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsEventCreateSchemaData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsEventCreateSchemaData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsEventCreateSchemaData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRuleDeleteResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRuleDeleteResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfAnalyticsRuleDeleteResponse = [1]string{
	0: "name",
}

// Decode decodes AnalyticsRuleDeleteResponse from json.
func (s *AnalyticsRuleDeleteResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleDeleteResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRuleDeleteResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsRuleDeleteResponse) {
					name = jsonFieldsNameOfAnalyticsRuleDeleteResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRuleDeleteResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleDeleteResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRuleParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRuleParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("destination")
		s.Destination.Encode(e)
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.ExpandQuery.Set {
			e.FieldStart("expand_query")
			s.ExpandQuery.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyticsRuleParameters = [4]string{
	0: "source",
	1: "destination",
	2: "limit",
	3: "expand_query",
}

// Decode decodes AnalyticsRuleParameters from json.
func (s *AnalyticsRuleParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "destination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "expand_query":
			if err := func() error {
				s.ExpandQuery.Reset()
				if err := s.ExpandQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expand_query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRuleParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsRuleParameters) {
					name = jsonFieldsNameOfAnalyticsRuleParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRuleParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRuleParametersDestination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRuleParametersDestination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("collection")
		e.Str(s.Collection)
	}
	{
		if s.CounterField.Set {
			e.FieldStart("counter_field")
			s.CounterField.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyticsRuleParametersDestination = [2]string{
	0: "collection",
	1: "counter_field",
}

// Decode decodes AnalyticsRuleParametersDestination from json.
func (s *AnalyticsRuleParametersDestination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleParametersDestination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collection":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Collection = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collection\"")
			}
		case "counter_field":
			if err := func() error {
				s.CounterField.Reset()
				if err := s.CounterField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"counter_field\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRuleParametersDestination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsRuleParametersDestination) {
					name = jsonFieldsNameOfAnalyticsRuleParametersDestination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRuleParametersDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleParametersDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRuleParametersSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRuleParametersSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("collections")
		e.ArrStart()
		for _, elem := range s.Collections {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAnalyticsRuleParametersSource = [2]string{
	0: "collections",
	1: "events",
}

// Decode decodes AnalyticsRuleParametersSource from json.
func (s *AnalyticsRuleParametersSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleParametersSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collections":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Collections = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Collections = append(s.Collections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collections\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]AnalyticsRuleParametersSourceEventsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnalyticsRuleParametersSourceEventsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRuleParametersSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsRuleParametersSource) {
					name = jsonFieldsNameOfAnalyticsRuleParametersSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRuleParametersSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleParametersSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRuleParametersSourceEventsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRuleParametersSourceEventsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("weight")
		e.Float32(s.Weight)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfAnalyticsRuleParametersSourceEventsItem = [3]string{
	0: "type",
	1: "weight",
	2: "name",
}

// Decode decodes AnalyticsRuleParametersSourceEventsItem from json.
func (s *AnalyticsRuleParametersSourceEventsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleParametersSourceEventsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Weight = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRuleParametersSourceEventsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsRuleParametersSourceEventsItem) {
					name = jsonFieldsNameOfAnalyticsRuleParametersSourceEventsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRuleParametersSourceEventsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleParametersSourceEventsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRuleSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRuleSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("params")
		s.Params.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfAnalyticsRuleSchema = [3]string{
	0: "type",
	1: "params",
	2: "name",
}

// Decode decodes AnalyticsRuleSchema from json.
func (s *AnalyticsRuleSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "params":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Params.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRuleSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsRuleSchema) {
					name = jsonFieldsNameOfAnalyticsRuleSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRuleSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalyticsRuleSchemaType as json.
func (s AnalyticsRuleSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnalyticsRuleSchemaType from json.
func (s *AnalyticsRuleSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnalyticsRuleSchemaType(v) {
	case AnalyticsRuleSchemaTypePopularQueries:
		*s = AnalyticsRuleSchemaTypePopularQueries
	case AnalyticsRuleSchemaTypeNohitsQueries:
		*s = AnalyticsRuleSchemaTypeNohitsQueries
	case AnalyticsRuleSchemaTypeCounter:
		*s = AnalyticsRuleSchemaTypeCounter
	default:
		*s = AnalyticsRuleSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnalyticsRuleSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRuleUpsertSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRuleUpsertSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("params")
		s.Params.Encode(e)
	}
}

var jsonFieldsNameOfAnalyticsRuleUpsertSchema = [2]string{
	0: "type",
	1: "params",
}

// Decode decodes AnalyticsRuleUpsertSchema from json.
func (s *AnalyticsRuleUpsertSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleUpsertSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "params":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Params.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRuleUpsertSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsRuleUpsertSchema) {
					name = jsonFieldsNameOfAnalyticsRuleUpsertSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRuleUpsertSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleUpsertSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalyticsRuleUpsertSchemaType as json.
func (s AnalyticsRuleUpsertSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnalyticsRuleUpsertSchemaType from json.
func (s *AnalyticsRuleUpsertSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRuleUpsertSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnalyticsRuleUpsertSchemaType(v) {
	case AnalyticsRuleUpsertSchemaTypePopularQueries:
		*s = AnalyticsRuleUpsertSchemaTypePopularQueries
	case AnalyticsRuleUpsertSchemaTypeNohitsQueries:
		*s = AnalyticsRuleUpsertSchemaTypeNohitsQueries
	case AnalyticsRuleUpsertSchemaTypeCounter:
		*s = AnalyticsRuleUpsertSchemaTypeCounter
	default:
		*s = AnalyticsRuleUpsertSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnalyticsRuleUpsertSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRuleUpsertSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsRulesRetrieveSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsRulesRetrieveSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAnalyticsRulesRetrieveSchema = [1]string{
	0: "rules",
}

// Decode decodes AnalyticsRulesRetrieveSchema from json.
func (s *AnalyticsRulesRetrieveSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsRulesRetrieveSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rules":
			if err := func() error {
				s.Rules = make([]AnalyticsRuleSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnalyticsRuleSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsRulesRetrieveSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsRulesRetrieveSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsRulesRetrieveSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiKey) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("actions")
		e.ArrStart()
		for _, elem := range s.Actions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("collections")
		e.ArrStart()
		for _, elem := range s.Collections {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ValuePrefix.Set {
			e.FieldStart("value_prefix")
			s.ValuePrefix.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiKey = [7]string{
	0: "value",
	1: "description",
	2: "actions",
	3: "collections",
	4: "expires_at",
	5: "id",
	6: "value_prefix",
}

// Decode decodes ApiKey from json.
func (s *ApiKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiKey to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "actions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Actions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		case "collections":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Collections = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Collections = append(s.Collections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collections\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "value_prefix":
			if err := func() error {
				s.ValuePrefix.Reset()
				if err := s.ValuePrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_prefix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiKey) {
					name = jsonFieldsNameOfApiKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiKeyDeleteResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiKeyDeleteResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
}

var jsonFieldsNameOfApiKeyDeleteResponse = [1]string{
	0: "id",
}

// Decode decodes ApiKeyDeleteResponse from json.
func (s *ApiKeyDeleteResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiKeyDeleteResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiKeyDeleteResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiKeyDeleteResponse) {
					name = jsonFieldsNameOfApiKeyDeleteResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiKeyDeleteResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiKeyDeleteResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiKeySchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiKeySchema) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("actions")
		e.ArrStart()
		for _, elem := range s.Actions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("collections")
		e.ArrStart()
		for _, elem := range s.Collections {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiKeySchema = [5]string{
	0: "value",
	1: "description",
	2: "actions",
	3: "collections",
	4: "expires_at",
}

// Decode decodes ApiKeySchema from json.
func (s *ApiKeySchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiKeySchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "actions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Actions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		case "collections":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Collections = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Collections = append(s.Collections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collections\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiKeySchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiKeySchema) {
					name = jsonFieldsNameOfApiKeySchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiKeySchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiKeySchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiKeysResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiKeysResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("keys")
		e.ArrStart()
		for _, elem := range s.Keys {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfApiKeysResponse = [1]string{
	0: "keys",
}

// Decode decodes ApiKeysResponse from json.
func (s *ApiKeysResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiKeysResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keys":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Keys = make([]ApiKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ApiKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Keys = append(s.Keys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiKeysResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiKeysResponse) {
					name = jsonFieldsNameOfApiKeysResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiKeysResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiKeysResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfApiResponse = [1]string{
	0: "message",
}

// Decode decodes ApiResponse from json.
func (s *ApiResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiResponse) {
					name = jsonFieldsNameOfApiResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionAlias) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionAlias) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("collection_name")
		e.Str(s.CollectionName)
	}
}

var jsonFieldsNameOfCollectionAlias = [2]string{
	0: "name",
	1: "collection_name",
}

// Decode decodes CollectionAlias from json.
func (s *CollectionAlias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionAlias to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "collection_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CollectionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collection_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollectionAlias")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollectionAlias) {
					name = jsonFieldsNameOfCollectionAlias[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionAlias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionAlias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionAliasSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionAliasSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("collection_name")
		e.Str(s.CollectionName)
	}
}

var jsonFieldsNameOfCollectionAliasSchema = [1]string{
	0: "collection_name",
}

// Decode decodes CollectionAliasSchema from json.
func (s *CollectionAliasSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionAliasSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collection_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CollectionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collection_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollectionAliasSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollectionAliasSchema) {
					name = jsonFieldsNameOfCollectionAliasSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionAliasSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionAliasSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionAliasesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionAliasesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("aliases")
		e.ArrStart()
		for _, elem := range s.Aliases {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCollectionAliasesResponse = [1]string{
	0: "aliases",
}

// Decode decodes CollectionAliasesResponse from json.
func (s *CollectionAliasesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionAliasesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aliases":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Aliases = make([]CollectionAlias, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CollectionAlias
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Aliases = append(s.Aliases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aliases\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollectionAliasesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollectionAliasesResponse) {
					name = jsonFieldsNameOfCollectionAliasesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionAliasesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionAliasesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("fields")
		e.ArrStart()
		for _, elem := range s.Fields {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DefaultSortingField.Set {
			e.FieldStart("default_sorting_field")
			s.DefaultSortingField.Encode(e)
		}
	}
	{
		if s.TokenSeparators != nil {
			e.FieldStart("token_separators")
			e.ArrStart()
			for _, elem := range s.TokenSeparators {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnableNestedFields.Set {
			e.FieldStart("enable_nested_fields")
			s.EnableNestedFields.Encode(e)
		}
	}
	{
		if s.SymbolsToIndex != nil {
			e.FieldStart("symbols_to_index")
			e.ArrStart()
			for _, elem := range s.SymbolsToIndex {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VoiceQueryModel.Set {
			e.FieldStart("voice_query_model")
			s.VoiceQueryModel.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("num_documents")
		e.Int64(s.NumDocuments)
	}
	{
		e.FieldStart("created_at")
		e.Int64(s.CreatedAt)
	}
}

var jsonFieldsNameOfCollectionResponse = [10]string{
	0: "name",
	1: "fields",
	2: "default_sorting_field",
	3: "token_separators",
	4: "enable_nested_fields",
	5: "symbols_to_index",
	6: "voice_query_model",
	7: "metadata",
	8: "num_documents",
	9: "created_at",
}

// Decode decodes CollectionResponse from json.
func (s *CollectionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "fields":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Fields = make([]Field, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Field
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Fields = append(s.Fields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fields\"")
			}
		case "default_sorting_field":
			if err := func() error {
				s.DefaultSortingField.Reset()
				if err := s.DefaultSortingField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_sorting_field\"")
			}
		case "token_separators":
			if err := func() error {
				s.TokenSeparators = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TokenSeparators = append(s.TokenSeparators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_separators\"")
			}
		case "enable_nested_fields":
			if err := func() error {
				s.EnableNestedFields.Reset()
				if err := s.EnableNestedFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_nested_fields\"")
			}
		case "symbols_to_index":
			if err := func() error {
				s.SymbolsToIndex = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SymbolsToIndex = append(s.SymbolsToIndex, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols_to_index\"")
			}
		case "voice_query_model":
			if err := func() error {
				s.VoiceQueryModel.Reset()
				if err := s.VoiceQueryModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_query_model\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem CollectionResponseMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "num_documents":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.NumDocuments = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_documents\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.CreatedAt = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollectionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollectionResponse) {
					name = jsonFieldsNameOfCollectionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionResponseMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionResponseMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCollectionResponseMetadata = [0]string{}

// Decode decodes CollectionResponseMetadata from json.
func (s *CollectionResponseMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionResponseMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CollectionResponseMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionResponseMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionResponseMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("fields")
		e.ArrStart()
		for _, elem := range s.Fields {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DefaultSortingField.Set {
			e.FieldStart("default_sorting_field")
			s.DefaultSortingField.Encode(e)
		}
	}
	{
		if s.TokenSeparators != nil {
			e.FieldStart("token_separators")
			e.ArrStart()
			for _, elem := range s.TokenSeparators {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnableNestedFields.Set {
			e.FieldStart("enable_nested_fields")
			s.EnableNestedFields.Encode(e)
		}
	}
	{
		if s.SymbolsToIndex != nil {
			e.FieldStart("symbols_to_index")
			e.ArrStart()
			for _, elem := range s.SymbolsToIndex {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VoiceQueryModel.Set {
			e.FieldStart("voice_query_model")
			s.VoiceQueryModel.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCollectionSchema = [8]string{
	0: "name",
	1: "fields",
	2: "default_sorting_field",
	3: "token_separators",
	4: "enable_nested_fields",
	5: "symbols_to_index",
	6: "voice_query_model",
	7: "metadata",
}

// Decode decodes CollectionSchema from json.
func (s *CollectionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "fields":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Fields = make([]Field, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Field
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Fields = append(s.Fields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fields\"")
			}
		case "default_sorting_field":
			if err := func() error {
				s.DefaultSortingField.Reset()
				if err := s.DefaultSortingField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_sorting_field\"")
			}
		case "token_separators":
			if err := func() error {
				s.TokenSeparators = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TokenSeparators = append(s.TokenSeparators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_separators\"")
			}
		case "enable_nested_fields":
			if err := func() error {
				s.EnableNestedFields.Reset()
				if err := s.EnableNestedFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_nested_fields\"")
			}
		case "symbols_to_index":
			if err := func() error {
				s.SymbolsToIndex = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SymbolsToIndex = append(s.SymbolsToIndex, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols_to_index\"")
			}
		case "voice_query_model":
			if err := func() error {
				s.VoiceQueryModel.Reset()
				if err := s.VoiceQueryModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_query_model\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem CollectionSchemaMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollectionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollectionSchema) {
					name = jsonFieldsNameOfCollectionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionSchemaMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionSchemaMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCollectionSchemaMetadata = [0]string{}

// Decode decodes CollectionSchemaMetadata from json.
func (s *CollectionSchemaMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionSchemaMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CollectionSchemaMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionSchemaMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionSchemaMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionUpdateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionUpdateSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fields")
		e.ArrStart()
		for _, elem := range s.Fields {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCollectionUpdateSchema = [2]string{
	0: "fields",
	1: "metadata",
}

// Decode decodes CollectionUpdateSchema from json.
func (s *CollectionUpdateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionUpdateSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fields":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Fields = make([]Field, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Field
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Fields = append(s.Fields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fields\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem CollectionUpdateSchemaMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollectionUpdateSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollectionUpdateSchema) {
					name = jsonFieldsNameOfCollectionUpdateSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionUpdateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionUpdateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollectionUpdateSchemaMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollectionUpdateSchemaMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCollectionUpdateSchemaMetadata = [0]string{}

// Decode decodes CollectionUpdateSchemaMetadata from json.
func (s *CollectionUpdateSchemaMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollectionUpdateSchemaMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CollectionUpdateSchemaMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollectionUpdateSchemaMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollectionUpdateSchemaMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationModelCreateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationModelCreateSchema) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("model_name")
		e.Str(s.ModelName)
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		e.FieldStart("history_collection")
		e.Str(s.HistoryCollection)
	}
	{
		if s.AccountID.Set {
			e.FieldStart("account_id")
			s.AccountID.Encode(e)
		}
	}
	{
		if s.SystemPrompt.Set {
			e.FieldStart("system_prompt")
			s.SystemPrompt.Encode(e)
		}
	}
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		e.FieldStart("max_bytes")
		e.Int(s.MaxBytes)
	}
	{
		if s.VllmURL.Set {
			e.FieldStart("vllm_url")
			s.VllmURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationModelCreateSchema = [9]string{
	0: "id",
	1: "model_name",
	2: "api_key",
	3: "history_collection",
	4: "account_id",
	5: "system_prompt",
	6: "ttl",
	7: "max_bytes",
	8: "vllm_url",
}

// Decode decodes ConversationModelCreateSchema from json.
func (s *ConversationModelCreateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationModelCreateSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "model_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ModelName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "history_collection":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HistoryCollection = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history_collection\"")
			}
		case "account_id":
			if err := func() error {
				s.AccountID.Reset()
				if err := s.AccountID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "system_prompt":
			if err := func() error {
				s.SystemPrompt.Reset()
				if err := s.SystemPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_prompt\"")
			}
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "max_bytes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.MaxBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_bytes\"")
			}
		case "vllm_url":
			if err := func() error {
				s.VllmURL.Reset()
				if err := s.VllmURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vllm_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationModelCreateSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationModelCreateSchema) {
					name = jsonFieldsNameOfConversationModelCreateSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationModelCreateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationModelCreateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationModelSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationModelSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("model_name")
		e.Str(s.ModelName)
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		e.FieldStart("history_collection")
		e.Str(s.HistoryCollection)
	}
	{
		if s.AccountID.Set {
			e.FieldStart("account_id")
			s.AccountID.Encode(e)
		}
	}
	{
		if s.SystemPrompt.Set {
			e.FieldStart("system_prompt")
			s.SystemPrompt.Encode(e)
		}
	}
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		e.FieldStart("max_bytes")
		e.Int(s.MaxBytes)
	}
	{
		if s.VllmURL.Set {
			e.FieldStart("vllm_url")
			s.VllmURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationModelSchema = [9]string{
	0: "id",
	1: "model_name",
	2: "api_key",
	3: "history_collection",
	4: "account_id",
	5: "system_prompt",
	6: "ttl",
	7: "max_bytes",
	8: "vllm_url",
}

// Decode decodes ConversationModelSchema from json.
func (s *ConversationModelSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationModelSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "model_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ModelName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "history_collection":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HistoryCollection = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history_collection\"")
			}
		case "account_id":
			if err := func() error {
				s.AccountID.Reset()
				if err := s.AccountID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "system_prompt":
			if err := func() error {
				s.SystemPrompt.Reset()
				if err := s.SystemPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_prompt\"")
			}
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "max_bytes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.MaxBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_bytes\"")
			}
		case "vllm_url":
			if err := func() error {
				s.VllmURL.Reset()
				if err := s.VllmURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vllm_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationModelSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10001011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationModelSchema) {
					name = jsonFieldsNameOfConversationModelSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationModelSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationModelSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationModelUpdateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationModelUpdateSchema) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ModelName.Set {
			e.FieldStart("model_name")
			s.ModelName.Encode(e)
		}
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.HistoryCollection.Set {
			e.FieldStart("history_collection")
			s.HistoryCollection.Encode(e)
		}
	}
	{
		if s.AccountID.Set {
			e.FieldStart("account_id")
			s.AccountID.Encode(e)
		}
	}
	{
		if s.SystemPrompt.Set {
			e.FieldStart("system_prompt")
			s.SystemPrompt.Encode(e)
		}
	}
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		if s.MaxBytes.Set {
			e.FieldStart("max_bytes")
			s.MaxBytes.Encode(e)
		}
	}
	{
		if s.VllmURL.Set {
			e.FieldStart("vllm_url")
			s.VllmURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationModelUpdateSchema = [9]string{
	0: "id",
	1: "model_name",
	2: "api_key",
	3: "history_collection",
	4: "account_id",
	5: "system_prompt",
	6: "ttl",
	7: "max_bytes",
	8: "vllm_url",
}

// Decode decodes ConversationModelUpdateSchema from json.
func (s *ConversationModelUpdateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationModelUpdateSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "model_name":
			if err := func() error {
				s.ModelName.Reset()
				if err := s.ModelName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "history_collection":
			if err := func() error {
				s.HistoryCollection.Reset()
				if err := s.HistoryCollection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history_collection\"")
			}
		case "account_id":
			if err := func() error {
				s.AccountID.Reset()
				if err := s.AccountID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "system_prompt":
			if err := func() error {
				s.SystemPrompt.Reset()
				if err := s.SystemPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_prompt\"")
			}
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "max_bytes":
			if err := func() error {
				s.MaxBytes.Reset()
				if err := s.MaxBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_bytes\"")
			}
		case "vllm_url":
			if err := func() error {
				s.VllmURL.Reset()
				if err := s.VllmURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vllm_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationModelUpdateSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationModelUpdateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationModelUpdateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCollectionBadRequest as json.
func (s *CreateCollectionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateCollectionBadRequest from json.
func (s *CreateCollectionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCollectionBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateCollectionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCollectionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCollectionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCollectionConflict as json.
func (s *CreateCollectionConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateCollectionConflict from json.
func (s *CreateCollectionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCollectionConflict to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateCollectionConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCollectionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCollectionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateKeyBadRequest as json.
func (s *CreateKeyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateKeyBadRequest from json.
func (s *CreateKeyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateKeyBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateKeyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateKeyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateKeyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateKeyConflict as json.
func (s *CreateKeyConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateKeyConflict from json.
func (s *CreateKeyConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateKeyConflict to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateKeyConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateKeyConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateKeyConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugOK) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugOK = [1]string{
	0: "version",
}

// Decode decodes DebugOK from json.
func (s *DebugOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteDocumentOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteDocumentOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDeleteDocumentOK = [0]string{}

// Decode decodes DeleteDocumentOK from json.
func (s *DeleteDocumentOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDocumentOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DeleteDocumentOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDocumentOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDocumentOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteDocumentsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteDocumentsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("num_deleted")
		e.Int(s.NumDeleted)
	}
}

var jsonFieldsNameOfDeleteDocumentsOK = [1]string{
	0: "num_deleted",
}

// Decode decodes DeleteDocumentsOK from json.
func (s *DeleteDocumentsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDocumentsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "num_deleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.NumDeleted = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_deleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteDocumentsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteDocumentsOK) {
					name = jsonFieldsNameOfDeleteDocumentsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDocumentsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDocumentsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteKeyBadRequest as json.
func (s *DeleteKeyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteKeyBadRequest from json.
func (s *DeleteKeyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteKeyBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteKeyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteKeyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteKeyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteKeyNotFound as json.
func (s *DeleteKeyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteKeyNotFound from json.
func (s *DeleteKeyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteKeyNotFound to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteKeyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteKeyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteKeyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteStopwordsSetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteStopwordsSetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfDeleteStopwordsSetOK = [1]string{
	0: "id",
}

// Decode decodes DeleteStopwordsSetOK from json.
func (s *DeleteStopwordsSetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStopwordsSetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteStopwordsSetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteStopwordsSetOK) {
					name = jsonFieldsNameOfDeleteStopwordsSetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStopwordsSetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStopwordsSetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DropTokensMode as json.
func (s DropTokensMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DropTokensMode from json.
func (s *DropTokensMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DropTokensMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DropTokensMode(v) {
	case DropTokensModeRightToLeft:
		*s = DropTokensModeRightToLeft
	case DropTokensModeLeftToRight:
		*s = DropTokensModeLeftToRight
	case DropTokensModeBothSides3:
		*s = DropTokensModeBothSides3
	default:
		*s = DropTokensMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DropTokensMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DropTokensMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FacetCounts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FacetCounts) encodeFields(e *jx.Encoder) {
	{
		if s.Counts != nil {
			e.FieldStart("counts")
			e.ArrStart()
			for _, elem := range s.Counts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FieldName.Set {
			e.FieldStart("field_name")
			s.FieldName.Encode(e)
		}
	}
	{
		if s.Stats.Set {
			e.FieldStart("stats")
			s.Stats.Encode(e)
		}
	}
}

var jsonFieldsNameOfFacetCounts = [3]string{
	0: "counts",
	1: "field_name",
	2: "stats",
}

// Decode decodes FacetCounts from json.
func (s *FacetCounts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacetCounts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "counts":
			if err := func() error {
				s.Counts = make([]FacetCountsCountsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FacetCountsCountsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Counts = append(s.Counts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"counts\"")
			}
		case "field_name":
			if err := func() error {
				s.FieldName.Reset()
				if err := s.FieldName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field_name\"")
			}
		case "stats":
			if err := func() error {
				s.Stats.Reset()
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FacetCounts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacetCounts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacetCounts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FacetCountsCountsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FacetCountsCountsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.Highlighted.Set {
			e.FieldStart("highlighted")
			s.Highlighted.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Parent != nil {
			e.FieldStart("parent")
			s.Parent.Encode(e)
		}
	}
}

var jsonFieldsNameOfFacetCountsCountsItem = [4]string{
	0: "count",
	1: "highlighted",
	2: "value",
	3: "parent",
}

// Decode decodes FacetCountsCountsItem from json.
func (s *FacetCountsCountsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacetCountsCountsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "highlighted":
			if err := func() error {
				s.Highlighted.Reset()
				if err := s.Highlighted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlighted\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "parent":
			if err := func() error {
				s.Parent = nil
				var elem FacetCountsCountsItemParent
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parent = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FacetCountsCountsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacetCountsCountsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacetCountsCountsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FacetCountsCountsItemParent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FacetCountsCountsItemParent) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfFacetCountsCountsItemParent = [0]string{}

// Decode decodes FacetCountsCountsItemParent from json.
func (s *FacetCountsCountsItemParent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacetCountsCountsItemParent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode FacetCountsCountsItemParent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacetCountsCountsItemParent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacetCountsCountsItemParent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FacetCountsStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FacetCountsStats) encodeFields(e *jx.Encoder) {
	{
		if s.Max.Set {
			e.FieldStart("max")
			s.Max.Encode(e)
		}
	}
	{
		if s.Min.Set {
			e.FieldStart("min")
			s.Min.Encode(e)
		}
	}
	{
		if s.Sum.Set {
			e.FieldStart("sum")
			s.Sum.Encode(e)
		}
	}
	{
		if s.TotalValues.Set {
			e.FieldStart("total_values")
			s.TotalValues.Encode(e)
		}
	}
	{
		if s.Avg.Set {
			e.FieldStart("avg")
			s.Avg.Encode(e)
		}
	}
}

var jsonFieldsNameOfFacetCountsStats = [5]string{
	0: "max",
	1: "min",
	2: "sum",
	3: "total_values",
	4: "avg",
}

// Decode decodes FacetCountsStats from json.
func (s *FacetCountsStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacetCountsStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max":
			if err := func() error {
				s.Max.Reset()
				if err := s.Max.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "min":
			if err := func() error {
				s.Min.Reset()
				if err := s.Min.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		case "sum":
			if err := func() error {
				s.Sum.Reset()
				if err := s.Sum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sum\"")
			}
		case "total_values":
			if err := func() error {
				s.TotalValues.Reset()
				if err := s.TotalValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_values\"")
			}
		case "avg":
			if err := func() error {
				s.Avg.Reset()
				if err := s.Avg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FacetCountsStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacetCountsStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacetCountsStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Field) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Field) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
	{
		if s.Facet.Set {
			e.FieldStart("facet")
			s.Facet.Encode(e)
		}
	}
	{
		if s.Index.Set {
			e.FieldStart("index")
			s.Index.Encode(e)
		}
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
	{
		if s.Sort.Set {
			e.FieldStart("sort")
			s.Sort.Encode(e)
		}
	}
	{
		if s.Infix.Set {
			e.FieldStart("infix")
			s.Infix.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
	{
		if s.NumDim.Set {
			e.FieldStart("num_dim")
			s.NumDim.Encode(e)
		}
	}
	{
		if s.Drop.Set {
			e.FieldStart("drop")
			s.Drop.Encode(e)
		}
	}
	{
		if s.Store.Set {
			e.FieldStart("store")
			s.Store.Encode(e)
		}
	}
	{
		if s.VecDist.Set {
			e.FieldStart("vec_dist")
			s.VecDist.Encode(e)
		}
	}
	{
		if s.RangeIndex.Set {
			e.FieldStart("range_index")
			s.RangeIndex.Encode(e)
		}
	}
	{
		if s.Stem.Set {
			e.FieldStart("stem")
			s.Stem.Encode(e)
		}
	}
	{
		if s.StemDictionary.Set {
			e.FieldStart("stem_dictionary")
			s.StemDictionary.Encode(e)
		}
	}
	{
		if s.TokenSeparators != nil {
			e.FieldStart("token_separators")
			e.ArrStart()
			for _, elem := range s.TokenSeparators {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SymbolsToIndex != nil {
			e.FieldStart("symbols_to_index")
			e.ArrStart()
			for _, elem := range s.SymbolsToIndex {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Embed.Set {
			e.FieldStart("embed")
			s.Embed.Encode(e)
		}
	}
}

var jsonFieldsNameOfField = [19]string{
	0:  "name",
	1:  "type",
	2:  "optional",
	3:  "facet",
	4:  "index",
	5:  "locale",
	6:  "sort",
	7:  "infix",
	8:  "reference",
	9:  "num_dim",
	10: "drop",
	11: "store",
	12: "vec_dist",
	13: "range_index",
	14: "stem",
	15: "stem_dictionary",
	16: "token_separators",
	17: "symbols_to_index",
	18: "embed",
}

// Decode decodes Field from json.
func (s *Field) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Field to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		case "facet":
			if err := func() error {
				s.Facet.Reset()
				if err := s.Facet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet\"")
			}
		case "index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "sort":
			if err := func() error {
				s.Sort.Reset()
				if err := s.Sort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort\"")
			}
		case "infix":
			if err := func() error {
				s.Infix.Reset()
				if err := s.Infix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"infix\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "num_dim":
			if err := func() error {
				s.NumDim.Reset()
				if err := s.NumDim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_dim\"")
			}
		case "drop":
			if err := func() error {
				s.Drop.Reset()
				if err := s.Drop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop\"")
			}
		case "store":
			if err := func() error {
				s.Store.Reset()
				if err := s.Store.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"store\"")
			}
		case "vec_dist":
			if err := func() error {
				s.VecDist.Reset()
				if err := s.VecDist.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vec_dist\"")
			}
		case "range_index":
			if err := func() error {
				s.RangeIndex.Reset()
				if err := s.RangeIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range_index\"")
			}
		case "stem":
			if err := func() error {
				s.Stem.Reset()
				if err := s.Stem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stem\"")
			}
		case "stem_dictionary":
			if err := func() error {
				s.StemDictionary.Reset()
				if err := s.StemDictionary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stem_dictionary\"")
			}
		case "token_separators":
			if err := func() error {
				s.TokenSeparators = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TokenSeparators = append(s.TokenSeparators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_separators\"")
			}
		case "symbols_to_index":
			if err := func() error {
				s.SymbolsToIndex = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SymbolsToIndex = append(s.SymbolsToIndex, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols_to_index\"")
			}
		case "embed":
			if err := func() error {
				s.Embed.Reset()
				if err := s.Embed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"embed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Field")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfField) {
					name = jsonFieldsNameOfField[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Field) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Field) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FieldEmbed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FieldEmbed) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("from")
		e.ArrStart()
		for _, elem := range s.From {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("model_config")
		s.ModelConfig.Encode(e)
	}
}

var jsonFieldsNameOfFieldEmbed = [2]string{
	0: "from",
	1: "model_config",
}

// Decode decodes FieldEmbed from json.
func (s *FieldEmbed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FieldEmbed to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.From = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.From = append(s.From, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "model_config":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ModelConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FieldEmbed")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFieldEmbed) {
					name = jsonFieldsNameOfFieldEmbed[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FieldEmbed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FieldEmbed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FieldEmbedModelConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FieldEmbedModelConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model_name")
		e.Str(s.ModelName)
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.AccessToken.Set {
			e.FieldStart("access_token")
			s.AccessToken.Encode(e)
		}
	}
	{
		if s.RefreshToken.Set {
			e.FieldStart("refresh_token")
			s.RefreshToken.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.FieldStart("client_id")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.FieldStart("client_secret")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.IndexingPrefix.Set {
			e.FieldStart("indexing_prefix")
			s.IndexingPrefix.Encode(e)
		}
	}
	{
		if s.QueryPrefix.Set {
			e.FieldStart("query_prefix")
			s.QueryPrefix.Encode(e)
		}
	}
}

var jsonFieldsNameOfFieldEmbedModelConfig = [10]string{
	0: "model_name",
	1: "api_key",
	2: "url",
	3: "access_token",
	4: "refresh_token",
	5: "client_id",
	6: "client_secret",
	7: "project_id",
	8: "indexing_prefix",
	9: "query_prefix",
}

// Decode decodes FieldEmbedModelConfig from json.
func (s *FieldEmbedModelConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FieldEmbedModelConfig to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ModelName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "access_token":
			if err := func() error {
				s.AccessToken.Reset()
				if err := s.AccessToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "refresh_token":
			if err := func() error {
				s.RefreshToken.Reset()
				if err := s.RefreshToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "indexing_prefix":
			if err := func() error {
				s.IndexingPrefix.Reset()
				if err := s.IndexingPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexing_prefix\"")
			}
		case "query_prefix":
			if err := func() error {
				s.QueryPrefix.Reset()
				if err := s.QueryPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_prefix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FieldEmbedModelConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFieldEmbedModelConfig) {
					name = jsonFieldsNameOfFieldEmbedModelConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FieldEmbedModelConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FieldEmbedModelConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDocumentOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDocumentOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDocumentOK = [0]string{}

// Decode decodes GetDocumentOK from json.
func (s *GetDocumentOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDocumentOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetDocumentOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDocumentOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDocumentOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfHealthStatus = [1]string{
	0: "ok",
}

// Decode decodes HealthStatus from json.
func (s *HealthStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ok":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthStatus) {
					name = jsonFieldsNameOfHealthStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImportDocumentsBadRequest as json.
func (s *ImportDocumentsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ImportDocumentsBadRequest from json.
func (s *ImportDocumentsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportDocumentsBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ImportDocumentsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportDocumentsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportDocumentsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImportDocumentsNotFound as json.
func (s *ImportDocumentsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ImportDocumentsNotFound from json.
func (s *ImportDocumentsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportDocumentsNotFound to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ImportDocumentsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportDocumentsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportDocumentsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IndexDocumentCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IndexDocumentCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIndexDocumentCreated = [0]string{}

// Decode decodes IndexDocumentCreated from json.
func (s *IndexDocumentCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndexDocumentCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IndexDocumentCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IndexDocumentCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndexDocumentCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IndexDocumentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IndexDocumentReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIndexDocumentReq = [0]string{}

// Decode decodes IndexDocumentReq from json.
func (s *IndexDocumentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndexDocumentReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IndexDocumentReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IndexDocumentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndexDocumentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListStemmingDictionariesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListStemmingDictionariesOK) encodeFields(e *jx.Encoder) {
	{
		if s.Dictionaries != nil {
			e.FieldStart("dictionaries")
			e.ArrStart()
			for _, elem := range s.Dictionaries {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListStemmingDictionariesOK = [1]string{
	0: "dictionaries",
}

// Decode decodes ListStemmingDictionariesOK from json.
func (s *ListStemmingDictionariesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListStemmingDictionariesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dictionaries":
			if err := func() error {
				s.Dictionaries = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Dictionaries = append(s.Dictionaries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dictionaries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListStemmingDictionariesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListStemmingDictionariesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListStemmingDictionariesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MultiSearchCollectionParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MultiSearchCollectionParameters) encodeFields(e *jx.Encoder) {
	{
		if s.Q.Set {
			e.FieldStart("q")
			s.Q.Encode(e)
		}
	}
	{
		if s.QueryBy.Set {
			e.FieldStart("query_by")
			s.QueryBy.Encode(e)
		}
	}
	{
		if s.QueryByWeights.Set {
			e.FieldStart("query_by_weights")
			s.QueryByWeights.Encode(e)
		}
	}
	{
		if s.TextMatchType.Set {
			e.FieldStart("text_match_type")
			s.TextMatchType.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.Infix.Set {
			e.FieldStart("infix")
			s.Infix.Encode(e)
		}
	}
	{
		if s.MaxExtraPrefix.Set {
			e.FieldStart("max_extra_prefix")
			s.MaxExtraPrefix.Encode(e)
		}
	}
	{
		if s.MaxExtraSuffix.Set {
			e.FieldStart("max_extra_suffix")
			s.MaxExtraSuffix.Encode(e)
		}
	}
	{
		if s.FilterBy.Set {
			e.FieldStart("filter_by")
			s.FilterBy.Encode(e)
		}
	}
	{
		if s.SortBy.Set {
			e.FieldStart("sort_by")
			s.SortBy.Encode(e)
		}
	}
	{
		if s.FacetBy.Set {
			e.FieldStart("facet_by")
			s.FacetBy.Encode(e)
		}
	}
	{
		if s.MaxFacetValues.Set {
			e.FieldStart("max_facet_values")
			s.MaxFacetValues.Encode(e)
		}
	}
	{
		if s.FacetQuery.Set {
			e.FieldStart("facet_query")
			s.FacetQuery.Encode(e)
		}
	}
	{
		if s.NumTypos.Set {
			e.FieldStart("num_typos")
			s.NumTypos.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PerPage.Set {
			e.FieldStart("per_page")
			s.PerPage.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.GroupBy.Set {
			e.FieldStart("group_by")
			s.GroupBy.Encode(e)
		}
	}
	{
		if s.GroupLimit.Set {
			e.FieldStart("group_limit")
			s.GroupLimit.Encode(e)
		}
	}
	{
		if s.GroupMissingValues.Set {
			e.FieldStart("group_missing_values")
			s.GroupMissingValues.Encode(e)
		}
	}
	{
		if s.IncludeFields.Set {
			e.FieldStart("include_fields")
			s.IncludeFields.Encode(e)
		}
	}
	{
		if s.ExcludeFields.Set {
			e.FieldStart("exclude_fields")
			s.ExcludeFields.Encode(e)
		}
	}
	{
		if s.HighlightFullFields.Set {
			e.FieldStart("highlight_full_fields")
			s.HighlightFullFields.Encode(e)
		}
	}
	{
		if s.HighlightAffixNumTokens.Set {
			e.FieldStart("highlight_affix_num_tokens")
			s.HighlightAffixNumTokens.Encode(e)
		}
	}
	{
		if s.HighlightStartTag.Set {
			e.FieldStart("highlight_start_tag")
			s.HighlightStartTag.Encode(e)
		}
	}
	{
		if s.HighlightEndTag.Set {
			e.FieldStart("highlight_end_tag")
			s.HighlightEndTag.Encode(e)
		}
	}
	{
		if s.SnippetThreshold.Set {
			e.FieldStart("snippet_threshold")
			s.SnippetThreshold.Encode(e)
		}
	}
	{
		if s.DropTokensThreshold.Set {
			e.FieldStart("drop_tokens_threshold")
			s.DropTokensThreshold.Encode(e)
		}
	}
	{
		if s.DropTokensMode.Set {
			e.FieldStart("drop_tokens_mode")
			s.DropTokensMode.Encode(e)
		}
	}
	{
		if s.TypoTokensThreshold.Set {
			e.FieldStart("typo_tokens_threshold")
			s.TypoTokensThreshold.Encode(e)
		}
	}
	{
		if s.EnableTyposForAlphaNumericalTokens.Set {
			e.FieldStart("enable_typos_for_alpha_numerical_tokens")
			s.EnableTyposForAlphaNumericalTokens.Encode(e)
		}
	}
	{
		if s.FilterCuratedHits.Set {
			e.FieldStart("filter_curated_hits")
			s.FilterCuratedHits.Encode(e)
		}
	}
	{
		if s.EnableSynonyms.Set {
			e.FieldStart("enable_synonyms")
			s.EnableSynonyms.Encode(e)
		}
	}
	{
		if s.SynonymPrefix.Set {
			e.FieldStart("synonym_prefix")
			s.SynonymPrefix.Encode(e)
		}
	}
	{
		if s.SynonymNumTypos.Set {
			e.FieldStart("synonym_num_typos")
			s.SynonymNumTypos.Encode(e)
		}
	}
	{
		if s.PinnedHits.Set {
			e.FieldStart("pinned_hits")
			s.PinnedHits.Encode(e)
		}
	}
	{
		if s.HiddenHits.Set {
			e.FieldStart("hidden_hits")
			s.HiddenHits.Encode(e)
		}
	}
	{
		if s.OverrideTags.Set {
			e.FieldStart("override_tags")
			s.OverrideTags.Encode(e)
		}
	}
	{
		if s.HighlightFields.Set {
			e.FieldStart("highlight_fields")
			s.HighlightFields.Encode(e)
		}
	}
	{
		if s.PreSegmentedQuery.Set {
			e.FieldStart("pre_segmented_query")
			s.PreSegmentedQuery.Encode(e)
		}
	}
	{
		if s.Preset.Set {
			e.FieldStart("preset")
			s.Preset.Encode(e)
		}
	}
	{
		if s.EnableOverrides.Set {
			e.FieldStart("enable_overrides")
			s.EnableOverrides.Encode(e)
		}
	}
	{
		if s.PrioritizeExactMatch.Set {
			e.FieldStart("prioritize_exact_match")
			s.PrioritizeExactMatch.Encode(e)
		}
	}
	{
		if s.PrioritizeTokenPosition.Set {
			e.FieldStart("prioritize_token_position")
			s.PrioritizeTokenPosition.Encode(e)
		}
	}
	{
		if s.PrioritizeNumMatchingFields.Set {
			e.FieldStart("prioritize_num_matching_fields")
			s.PrioritizeNumMatchingFields.Encode(e)
		}
	}
	{
		if s.EnableTyposForNumericalTokens.Set {
			e.FieldStart("enable_typos_for_numerical_tokens")
			s.EnableTyposForNumericalTokens.Encode(e)
		}
	}
	{
		if s.ExhaustiveSearch.Set {
			e.FieldStart("exhaustive_search")
			s.ExhaustiveSearch.Encode(e)
		}
	}
	{
		if s.SearchCutoffMs.Set {
			e.FieldStart("search_cutoff_ms")
			s.SearchCutoffMs.Encode(e)
		}
	}
	{
		if s.UseCache.Set {
			e.FieldStart("use_cache")
			s.UseCache.Encode(e)
		}
	}
	{
		if s.CacheTTL.Set {
			e.FieldStart("cache_ttl")
			s.CacheTTL.Encode(e)
		}
	}
	{
		if s.MinLen1typo.Set {
			e.FieldStart("min_len_1typo")
			s.MinLen1typo.Encode(e)
		}
	}
	{
		if s.MinLen2typo.Set {
			e.FieldStart("min_len_2typo")
			s.MinLen2typo.Encode(e)
		}
	}
	{
		if s.VectorQuery.Set {
			e.FieldStart("vector_query")
			s.VectorQuery.Encode(e)
		}
	}
	{
		if s.RemoteEmbeddingTimeoutMs.Set {
			e.FieldStart("remote_embedding_timeout_ms")
			s.RemoteEmbeddingTimeoutMs.Encode(e)
		}
	}
	{
		if s.RemoteEmbeddingNumTries.Set {
			e.FieldStart("remote_embedding_num_tries")
			s.RemoteEmbeddingNumTries.Encode(e)
		}
	}
	{
		if s.FacetStrategy.Set {
			e.FieldStart("facet_strategy")
			s.FacetStrategy.Encode(e)
		}
	}
	{
		if s.Stopwords.Set {
			e.FieldStart("stopwords")
			s.Stopwords.Encode(e)
		}
	}
	{
		if s.FacetReturnParent.Set {
			e.FieldStart("facet_return_parent")
			s.FacetReturnParent.Encode(e)
		}
	}
	{
		if s.VoiceQuery.Set {
			e.FieldStart("voice_query")
			s.VoiceQuery.Encode(e)
		}
	}
	{
		if s.Conversation.Set {
			e.FieldStart("conversation")
			s.Conversation.Encode(e)
		}
	}
	{
		if s.ConversationModelID.Set {
			e.FieldStart("conversation_model_id")
			s.ConversationModelID.Encode(e)
		}
	}
	{
		if s.ConversationID.Set {
			e.FieldStart("conversation_id")
			s.ConversationID.Encode(e)
		}
	}
	{
		if s.Collection.Set {
			e.FieldStart("collection")
			s.Collection.Encode(e)
		}
	}
	{
		if s.XMinusTypesenseMinusAPIMinusKey.Set {
			e.FieldStart("x-typesense-api-key")
			s.XMinusTypesenseMinusAPIMinusKey.Encode(e)
		}
	}
	{
		if s.RerankHybridMatches.Set {
			e.FieldStart("rerank_hybrid_matches")
			s.RerankHybridMatches.Encode(e)
		}
	}
}

var jsonFieldsNameOfMultiSearchCollectionParameters = [66]string{
	0:  "q",
	1:  "query_by",
	2:  "query_by_weights",
	3:  "text_match_type",
	4:  "prefix",
	5:  "infix",
	6:  "max_extra_prefix",
	7:  "max_extra_suffix",
	8:  "filter_by",
	9:  "sort_by",
	10: "facet_by",
	11: "max_facet_values",
	12: "facet_query",
	13: "num_typos",
	14: "page",
	15: "per_page",
	16: "limit",
	17: "offset",
	18: "group_by",
	19: "group_limit",
	20: "group_missing_values",
	21: "include_fields",
	22: "exclude_fields",
	23: "highlight_full_fields",
	24: "highlight_affix_num_tokens",
	25: "highlight_start_tag",
	26: "highlight_end_tag",
	27: "snippet_threshold",
	28: "drop_tokens_threshold",
	29: "drop_tokens_mode",
	30: "typo_tokens_threshold",
	31: "enable_typos_for_alpha_numerical_tokens",
	32: "filter_curated_hits",
	33: "enable_synonyms",
	34: "synonym_prefix",
	35: "synonym_num_typos",
	36: "pinned_hits",
	37: "hidden_hits",
	38: "override_tags",
	39: "highlight_fields",
	40: "pre_segmented_query",
	41: "preset",
	42: "enable_overrides",
	43: "prioritize_exact_match",
	44: "prioritize_token_position",
	45: "prioritize_num_matching_fields",
	46: "enable_typos_for_numerical_tokens",
	47: "exhaustive_search",
	48: "search_cutoff_ms",
	49: "use_cache",
	50: "cache_ttl",
	51: "min_len_1typo",
	52: "min_len_2typo",
	53: "vector_query",
	54: "remote_embedding_timeout_ms",
	55: "remote_embedding_num_tries",
	56: "facet_strategy",
	57: "stopwords",
	58: "facet_return_parent",
	59: "voice_query",
	60: "conversation",
	61: "conversation_model_id",
	62: "conversation_id",
	63: "collection",
	64: "x-typesense-api-key",
	65: "rerank_hybrid_matches",
}

// Decode decodes MultiSearchCollectionParameters from json.
func (s *MultiSearchCollectionParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MultiSearchCollectionParameters to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "q":
			if err := func() error {
				s.Q.Reset()
				if err := s.Q.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"q\"")
			}
		case "query_by":
			if err := func() error {
				s.QueryBy.Reset()
				if err := s.QueryBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_by\"")
			}
		case "query_by_weights":
			if err := func() error {
				s.QueryByWeights.Reset()
				if err := s.QueryByWeights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_by_weights\"")
			}
		case "text_match_type":
			if err := func() error {
				s.TextMatchType.Reset()
				if err := s.TextMatchType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_match_type\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "infix":
			if err := func() error {
				s.Infix.Reset()
				if err := s.Infix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"infix\"")
			}
		case "max_extra_prefix":
			if err := func() error {
				s.MaxExtraPrefix.Reset()
				if err := s.MaxExtraPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_extra_prefix\"")
			}
		case "max_extra_suffix":
			if err := func() error {
				s.MaxExtraSuffix.Reset()
				if err := s.MaxExtraSuffix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_extra_suffix\"")
			}
		case "filter_by":
			if err := func() error {
				s.FilterBy.Reset()
				if err := s.FilterBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_by\"")
			}
		case "sort_by":
			if err := func() error {
				s.SortBy.Reset()
				if err := s.SortBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort_by\"")
			}
		case "facet_by":
			if err := func() error {
				s.FacetBy.Reset()
				if err := s.FacetBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_by\"")
			}
		case "max_facet_values":
			if err := func() error {
				s.MaxFacetValues.Reset()
				if err := s.MaxFacetValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_facet_values\"")
			}
		case "facet_query":
			if err := func() error {
				s.FacetQuery.Reset()
				if err := s.FacetQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_query\"")
			}
		case "num_typos":
			if err := func() error {
				s.NumTypos.Reset()
				if err := s.NumTypos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_typos\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "per_page":
			if err := func() error {
				s.PerPage.Reset()
				if err := s.PerPage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"per_page\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "group_by":
			if err := func() error {
				s.GroupBy.Reset()
				if err := s.GroupBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_by\"")
			}
		case "group_limit":
			if err := func() error {
				s.GroupLimit.Reset()
				if err := s.GroupLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_limit\"")
			}
		case "group_missing_values":
			if err := func() error {
				s.GroupMissingValues.Reset()
				if err := s.GroupMissingValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_missing_values\"")
			}
		case "include_fields":
			if err := func() error {
				s.IncludeFields.Reset()
				if err := s.IncludeFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_fields\"")
			}
		case "exclude_fields":
			if err := func() error {
				s.ExcludeFields.Reset()
				if err := s.ExcludeFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_fields\"")
			}
		case "highlight_full_fields":
			if err := func() error {
				s.HighlightFullFields.Reset()
				if err := s.HighlightFullFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_full_fields\"")
			}
		case "highlight_affix_num_tokens":
			if err := func() error {
				s.HighlightAffixNumTokens.Reset()
				if err := s.HighlightAffixNumTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_affix_num_tokens\"")
			}
		case "highlight_start_tag":
			if err := func() error {
				s.HighlightStartTag.Reset()
				if err := s.HighlightStartTag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_start_tag\"")
			}
		case "highlight_end_tag":
			if err := func() error {
				s.HighlightEndTag.Reset()
				if err := s.HighlightEndTag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_end_tag\"")
			}
		case "snippet_threshold":
			if err := func() error {
				s.SnippetThreshold.Reset()
				if err := s.SnippetThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet_threshold\"")
			}
		case "drop_tokens_threshold":
			if err := func() error {
				s.DropTokensThreshold.Reset()
				if err := s.DropTokensThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_tokens_threshold\"")
			}
		case "drop_tokens_mode":
			if err := func() error {
				s.DropTokensMode.Reset()
				if err := s.DropTokensMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_tokens_mode\"")
			}
		case "typo_tokens_threshold":
			if err := func() error {
				s.TypoTokensThreshold.Reset()
				if err := s.TypoTokensThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typo_tokens_threshold\"")
			}
		case "enable_typos_for_alpha_numerical_tokens":
			if err := func() error {
				s.EnableTyposForAlphaNumericalTokens.Reset()
				if err := s.EnableTyposForAlphaNumericalTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_typos_for_alpha_numerical_tokens\"")
			}
		case "filter_curated_hits":
			if err := func() error {
				s.FilterCuratedHits.Reset()
				if err := s.FilterCuratedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_curated_hits\"")
			}
		case "enable_synonyms":
			if err := func() error {
				s.EnableSynonyms.Reset()
				if err := s.EnableSynonyms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_synonyms\"")
			}
		case "synonym_prefix":
			if err := func() error {
				s.SynonymPrefix.Reset()
				if err := s.SynonymPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonym_prefix\"")
			}
		case "synonym_num_typos":
			if err := func() error {
				s.SynonymNumTypos.Reset()
				if err := s.SynonymNumTypos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonym_num_typos\"")
			}
		case "pinned_hits":
			if err := func() error {
				s.PinnedHits.Reset()
				if err := s.PinnedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned_hits\"")
			}
		case "hidden_hits":
			if err := func() error {
				s.HiddenHits.Reset()
				if err := s.HiddenHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden_hits\"")
			}
		case "override_tags":
			if err := func() error {
				s.OverrideTags.Reset()
				if err := s.OverrideTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"override_tags\"")
			}
		case "highlight_fields":
			if err := func() error {
				s.HighlightFields.Reset()
				if err := s.HighlightFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_fields\"")
			}
		case "pre_segmented_query":
			if err := func() error {
				s.PreSegmentedQuery.Reset()
				if err := s.PreSegmentedQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_segmented_query\"")
			}
		case "preset":
			if err := func() error {
				s.Preset.Reset()
				if err := s.Preset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preset\"")
			}
		case "enable_overrides":
			if err := func() error {
				s.EnableOverrides.Reset()
				if err := s.EnableOverrides.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_overrides\"")
			}
		case "prioritize_exact_match":
			if err := func() error {
				s.PrioritizeExactMatch.Reset()
				if err := s.PrioritizeExactMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prioritize_exact_match\"")
			}
		case "prioritize_token_position":
			if err := func() error {
				s.PrioritizeTokenPosition.Reset()
				if err := s.PrioritizeTokenPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prioritize_token_position\"")
			}
		case "prioritize_num_matching_fields":
			if err := func() error {
				s.PrioritizeNumMatchingFields.Reset()
				if err := s.PrioritizeNumMatchingFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prioritize_num_matching_fields\"")
			}
		case "enable_typos_for_numerical_tokens":
			if err := func() error {
				s.EnableTyposForNumericalTokens.Reset()
				if err := s.EnableTyposForNumericalTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_typos_for_numerical_tokens\"")
			}
		case "exhaustive_search":
			if err := func() error {
				s.ExhaustiveSearch.Reset()
				if err := s.ExhaustiveSearch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exhaustive_search\"")
			}
		case "search_cutoff_ms":
			if err := func() error {
				s.SearchCutoffMs.Reset()
				if err := s.SearchCutoffMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_cutoff_ms\"")
			}
		case "use_cache":
			if err := func() error {
				s.UseCache.Reset()
				if err := s.UseCache.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_cache\"")
			}
		case "cache_ttl":
			if err := func() error {
				s.CacheTTL.Reset()
				if err := s.CacheTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_ttl\"")
			}
		case "min_len_1typo":
			if err := func() error {
				s.MinLen1typo.Reset()
				if err := s.MinLen1typo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_len_1typo\"")
			}
		case "min_len_2typo":
			if err := func() error {
				s.MinLen2typo.Reset()
				if err := s.MinLen2typo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_len_2typo\"")
			}
		case "vector_query":
			if err := func() error {
				s.VectorQuery.Reset()
				if err := s.VectorQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vector_query\"")
			}
		case "remote_embedding_timeout_ms":
			if err := func() error {
				s.RemoteEmbeddingTimeoutMs.Reset()
				if err := s.RemoteEmbeddingTimeoutMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_embedding_timeout_ms\"")
			}
		case "remote_embedding_num_tries":
			if err := func() error {
				s.RemoteEmbeddingNumTries.Reset()
				if err := s.RemoteEmbeddingNumTries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_embedding_num_tries\"")
			}
		case "facet_strategy":
			if err := func() error {
				s.FacetStrategy.Reset()
				if err := s.FacetStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_strategy\"")
			}
		case "stopwords":
			if err := func() error {
				s.Stopwords.Reset()
				if err := s.Stopwords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopwords\"")
			}
		case "facet_return_parent":
			if err := func() error {
				s.FacetReturnParent.Reset()
				if err := s.FacetReturnParent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_return_parent\"")
			}
		case "voice_query":
			if err := func() error {
				s.VoiceQuery.Reset()
				if err := s.VoiceQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_query\"")
			}
		case "conversation":
			if err := func() error {
				s.Conversation.Reset()
				if err := s.Conversation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation\"")
			}
		case "conversation_model_id":
			if err := func() error {
				s.ConversationModelID.Reset()
				if err := s.ConversationModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_model_id\"")
			}
		case "conversation_id":
			if err := func() error {
				s.ConversationID.Reset()
				if err := s.ConversationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "collection":
			if err := func() error {
				s.Collection.Reset()
				if err := s.Collection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collection\"")
			}
		case "x-typesense-api-key":
			if err := func() error {
				s.XMinusTypesenseMinusAPIMinusKey.Reset()
				if err := s.XMinusTypesenseMinusAPIMinusKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-typesense-api-key\"")
			}
		case "rerank_hybrid_matches":
			if err := func() error {
				s.RerankHybridMatches.Reset()
				if err := s.RerankHybridMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rerank_hybrid_matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MultiSearchCollectionParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MultiSearchCollectionParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MultiSearchCollectionParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MultiSearchResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MultiSearchResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Conversation.Set {
			e.FieldStart("conversation")
			s.Conversation.Encode(e)
		}
	}
}

var jsonFieldsNameOfMultiSearchResult = [2]string{
	0: "results",
	1: "conversation",
}

// Decode decodes MultiSearchResult from json.
func (s *MultiSearchResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MultiSearchResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]MultiSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MultiSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "conversation":
			if err := func() error {
				s.Conversation.Reset()
				if err := s.Conversation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MultiSearchResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMultiSearchResult) {
					name = jsonFieldsNameOfMultiSearchResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MultiSearchResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MultiSearchResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MultiSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MultiSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		if s.FacetCounts != nil {
			e.FieldStart("facet_counts")
			e.ArrStart()
			for _, elem := range s.FacetCounts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Found.Set {
			e.FieldStart("found")
			s.Found.Encode(e)
		}
	}
	{
		if s.FoundDocs.Set {
			e.FieldStart("found_docs")
			s.FoundDocs.Encode(e)
		}
	}
	{
		if s.SearchTimeMs.Set {
			e.FieldStart("search_time_ms")
			s.SearchTimeMs.Encode(e)
		}
	}
	{
		if s.OutOf.Set {
			e.FieldStart("out_of")
			s.OutOf.Encode(e)
		}
	}
	{
		if s.SearchCutoff.Set {
			e.FieldStart("search_cutoff")
			s.SearchCutoff.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.GroupedHits != nil {
			e.FieldStart("grouped_hits")
			e.ArrStart()
			for _, elem := range s.GroupedHits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hits != nil {
			e.FieldStart("hits")
			e.ArrStart()
			for _, elem := range s.Hits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequestParams.Set {
			e.FieldStart("request_params")
			s.RequestParams.Encode(e)
		}
	}
	{
		if s.Conversation.Set {
			e.FieldStart("conversation")
			s.Conversation.Encode(e)
		}
	}
	{
		if s.UnionRequestParams != nil {
			e.FieldStart("union_request_params")
			e.ArrStart()
			for _, elem := range s.UnionRequestParams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfMultiSearchResultItem = [14]string{
	0:  "facet_counts",
	1:  "found",
	2:  "found_docs",
	3:  "search_time_ms",
	4:  "out_of",
	5:  "search_cutoff",
	6:  "page",
	7:  "grouped_hits",
	8:  "hits",
	9:  "request_params",
	10: "conversation",
	11: "union_request_params",
	12: "code",
	13: "error",
}

// Decode decodes MultiSearchResultItem from json.
func (s *MultiSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MultiSearchResultItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "facet_counts":
			if err := func() error {
				s.FacetCounts = make([]FacetCounts, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FacetCounts
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FacetCounts = append(s.FacetCounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_counts\"")
			}
		case "found":
			if err := func() error {
				s.Found.Reset()
				if err := s.Found.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"found\"")
			}
		case "found_docs":
			if err := func() error {
				s.FoundDocs.Reset()
				if err := s.FoundDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"found_docs\"")
			}
		case "search_time_ms":
			if err := func() error {
				s.SearchTimeMs.Reset()
				if err := s.SearchTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_time_ms\"")
			}
		case "out_of":
			if err := func() error {
				s.OutOf.Reset()
				if err := s.OutOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"out_of\"")
			}
		case "search_cutoff":
			if err := func() error {
				s.SearchCutoff.Reset()
				if err := s.SearchCutoff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_cutoff\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "grouped_hits":
			if err := func() error {
				s.GroupedHits = make([]SearchGroupedHit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchGroupedHit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GroupedHits = append(s.GroupedHits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grouped_hits\"")
			}
		case "hits":
			if err := func() error {
				s.Hits = make([]SearchResultHit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultHit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hits = append(s.Hits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hits\"")
			}
		case "request_params":
			if err := func() error {
				s.RequestParams.Reset()
				if err := s.RequestParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_params\"")
			}
		case "conversation":
			if err := func() error {
				s.Conversation.Reset()
				if err := s.Conversation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation\"")
			}
		case "union_request_params":
			if err := func() error {
				s.UnionRequestParams = make([]SearchRequestParams, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchRequestParams
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UnionRequestParams = append(s.UnionRequestParams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"union_request_params\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MultiSearchResultItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MultiSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MultiSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MultiSearchSearchesParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MultiSearchSearchesParameter) encodeFields(e *jx.Encoder) {
	{
		if s.Union.Set {
			e.FieldStart("union")
			s.Union.Encode(e)
		}
	}
	{
		e.FieldStart("searches")
		e.ArrStart()
		for _, elem := range s.Searches {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMultiSearchSearchesParameter = [2]string{
	0: "union",
	1: "searches",
}

// Decode decodes MultiSearchSearchesParameter from json.
func (s *MultiSearchSearchesParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MultiSearchSearchesParameter to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "union":
			if err := func() error {
				s.Union.Reset()
				if err := s.Union.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"union\"")
			}
		case "searches":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Searches = make([]MultiSearchCollectionParameters, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MultiSearchCollectionParameters
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Searches = append(s.Searches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"searches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MultiSearchSearchesParameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMultiSearchSearchesParameter) {
					name = jsonFieldsNameOfMultiSearchSearchesParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MultiSearchSearchesParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MultiSearchSearchesParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NLSearchModelCreateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NLSearchModelCreateSchema) encodeFields(e *jx.Encoder) {
	{
		if s.ModelName.Set {
			e.FieldStart("model_name")
			s.ModelName.Encode(e)
		}
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.APIURL.Set {
			e.FieldStart("api_url")
			s.APIURL.Encode(e)
		}
	}
	{
		if s.MaxBytes.Set {
			e.FieldStart("max_bytes")
			s.MaxBytes.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.SystemPrompt.Set {
			e.FieldStart("system_prompt")
			s.SystemPrompt.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
	{
		if s.TopK.Set {
			e.FieldStart("top_k")
			s.TopK.Encode(e)
		}
	}
	{
		if s.StopSequences != nil {
			e.FieldStart("stop_sequences")
			e.ArrStart()
			for _, elem := range s.StopSequences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.AccessToken.Set {
			e.FieldStart("access_token")
			s.AccessToken.Encode(e)
		}
	}
	{
		if s.RefreshToken.Set {
			e.FieldStart("refresh_token")
			s.RefreshToken.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.FieldStart("client_id")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.FieldStart("client_secret")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.MaxOutputTokens.Set {
			e.FieldStart("max_output_tokens")
			s.MaxOutputTokens.Encode(e)
		}
	}
	{
		if s.AccountID.Set {
			e.FieldStart("account_id")
			s.AccountID.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNLSearchModelCreateSchema = [19]string{
	0:  "model_name",
	1:  "api_key",
	2:  "api_url",
	3:  "max_bytes",
	4:  "temperature",
	5:  "system_prompt",
	6:  "top_p",
	7:  "top_k",
	8:  "stop_sequences",
	9:  "api_version",
	10: "project_id",
	11: "access_token",
	12: "refresh_token",
	13: "client_id",
	14: "client_secret",
	15: "region",
	16: "max_output_tokens",
	17: "account_id",
	18: "id",
}

// Decode decodes NLSearchModelCreateSchema from json.
func (s *NLSearchModelCreateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NLSearchModelCreateSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_name":
			if err := func() error {
				s.ModelName.Reset()
				if err := s.ModelName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "api_url":
			if err := func() error {
				s.APIURL.Reset()
				if err := s.APIURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_url\"")
			}
		case "max_bytes":
			if err := func() error {
				s.MaxBytes.Reset()
				if err := s.MaxBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_bytes\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "system_prompt":
			if err := func() error {
				s.SystemPrompt.Reset()
				if err := s.SystemPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_prompt\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		case "top_k":
			if err := func() error {
				s.TopK.Reset()
				if err := s.TopK.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_k\"")
			}
		case "stop_sequences":
			if err := func() error {
				s.StopSequences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StopSequences = append(s.StopSequences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_sequences\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "access_token":
			if err := func() error {
				s.AccessToken.Reset()
				if err := s.AccessToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "refresh_token":
			if err := func() error {
				s.RefreshToken.Reset()
				if err := s.RefreshToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "max_output_tokens":
			if err := func() error {
				s.MaxOutputTokens.Reset()
				if err := s.MaxOutputTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_output_tokens\"")
			}
		case "account_id":
			if err := func() error {
				s.AccountID.Reset()
				if err := s.AccountID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NLSearchModelCreateSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NLSearchModelCreateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NLSearchModelCreateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NLSearchModelDeleteSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NLSearchModelDeleteSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfNLSearchModelDeleteSchema = [1]string{
	0: "id",
}

// Decode decodes NLSearchModelDeleteSchema from json.
func (s *NLSearchModelDeleteSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NLSearchModelDeleteSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NLSearchModelDeleteSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNLSearchModelDeleteSchema) {
					name = jsonFieldsNameOfNLSearchModelDeleteSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NLSearchModelDeleteSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NLSearchModelDeleteSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NLSearchModelSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NLSearchModelSchema) encodeFields(e *jx.Encoder) {
	{
		if s.ModelName.Set {
			e.FieldStart("model_name")
			s.ModelName.Encode(e)
		}
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.APIURL.Set {
			e.FieldStart("api_url")
			s.APIURL.Encode(e)
		}
	}
	{
		if s.MaxBytes.Set {
			e.FieldStart("max_bytes")
			s.MaxBytes.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.SystemPrompt.Set {
			e.FieldStart("system_prompt")
			s.SystemPrompt.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
	{
		if s.TopK.Set {
			e.FieldStart("top_k")
			s.TopK.Encode(e)
		}
	}
	{
		if s.StopSequences != nil {
			e.FieldStart("stop_sequences")
			e.ArrStart()
			for _, elem := range s.StopSequences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.AccessToken.Set {
			e.FieldStart("access_token")
			s.AccessToken.Encode(e)
		}
	}
	{
		if s.RefreshToken.Set {
			e.FieldStart("refresh_token")
			s.RefreshToken.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.FieldStart("client_id")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.FieldStart("client_secret")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.MaxOutputTokens.Set {
			e.FieldStart("max_output_tokens")
			s.MaxOutputTokens.Encode(e)
		}
	}
	{
		if s.AccountID.Set {
			e.FieldStart("account_id")
			s.AccountID.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfNLSearchModelSchema = [19]string{
	0:  "model_name",
	1:  "api_key",
	2:  "api_url",
	3:  "max_bytes",
	4:  "temperature",
	5:  "system_prompt",
	6:  "top_p",
	7:  "top_k",
	8:  "stop_sequences",
	9:  "api_version",
	10: "project_id",
	11: "access_token",
	12: "refresh_token",
	13: "client_id",
	14: "client_secret",
	15: "region",
	16: "max_output_tokens",
	17: "account_id",
	18: "id",
}

// Decode decodes NLSearchModelSchema from json.
func (s *NLSearchModelSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NLSearchModelSchema to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_name":
			if err := func() error {
				s.ModelName.Reset()
				if err := s.ModelName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "api_url":
			if err := func() error {
				s.APIURL.Reset()
				if err := s.APIURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_url\"")
			}
		case "max_bytes":
			if err := func() error {
				s.MaxBytes.Reset()
				if err := s.MaxBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_bytes\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "system_prompt":
			if err := func() error {
				s.SystemPrompt.Reset()
				if err := s.SystemPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_prompt\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		case "top_k":
			if err := func() error {
				s.TopK.Reset()
				if err := s.TopK.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_k\"")
			}
		case "stop_sequences":
			if err := func() error {
				s.StopSequences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StopSequences = append(s.StopSequences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_sequences\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "access_token":
			if err := func() error {
				s.AccessToken.Reset()
				if err := s.AccessToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "refresh_token":
			if err := func() error {
				s.RefreshToken.Reset()
				if err := s.RefreshToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "max_output_tokens":
			if err := func() error {
				s.MaxOutputTokens.Reset()
				if err := s.MaxOutputTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_output_tokens\"")
			}
		case "account_id":
			if err := func() error {
				s.AccountID.Reset()
				if err := s.AccountID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "id":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NLSearchModelSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNLSearchModelSchema) {
					name = jsonFieldsNameOfNLSearchModelSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NLSearchModelSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NLSearchModelSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApiKeySchema as json.
func (o OptApiKeySchema) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ApiKeySchema from json.
func (o *OptApiKeySchema) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApiKeySchema to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApiKeySchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApiKeySchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollectionAliasSchema as json.
func (o OptCollectionAliasSchema) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CollectionAliasSchema from json.
func (o *OptCollectionAliasSchema) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCollectionAliasSchema to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCollectionAliasSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCollectionAliasSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DropTokensMode as json.
func (o OptDropTokensMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DropTokensMode from json.
func (o *OptDropTokensMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDropTokensMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDropTokensMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDropTokensMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacetCountsStats as json.
func (o OptFacetCountsStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FacetCountsStats from json.
func (o *OptFacetCountsStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFacetCountsStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFacetCountsStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFacetCountsStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FieldEmbed as json.
func (o OptFieldEmbed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FieldEmbed from json.
func (o *OptFieldEmbed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFieldEmbed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFieldEmbed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFieldEmbed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MultiSearchSearchesParameter as json.
func (o OptMultiSearchSearchesParameter) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MultiSearchSearchesParameter from json.
func (o *OptMultiSearchSearchesParameter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMultiSearchSearchesParameter to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMultiSearchSearchesParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMultiSearchSearchesParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchOverrideRuleMatch as json.
func (o OptSearchOverrideRuleMatch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SearchOverrideRuleMatch from json.
func (o *OptSearchOverrideRuleMatch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchOverrideRuleMatch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchOverrideRuleMatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchOverrideRuleMatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchRequestParams as json.
func (o OptSearchRequestParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchRequestParams from json.
func (o *OptSearchRequestParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchRequestParams to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchRequestParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchRequestParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchRequestParamsVoiceQuery as json.
func (o OptSearchRequestParamsVoiceQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchRequestParamsVoiceQuery from json.
func (o *OptSearchRequestParamsVoiceQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchRequestParamsVoiceQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchRequestParamsVoiceQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchRequestParamsVoiceQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResultConversation as json.
func (o OptSearchResultConversation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchResultConversation from json.
func (o *OptSearchResultConversation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchResultConversation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchResultConversation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchResultConversation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResultHitDocument as json.
func (o OptSearchResultHitDocument) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchResultHitDocument from json.
func (o *OptSearchResultHitDocument) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchResultHitDocument to nil")
	}
	o.Set = true
	o.Value = make(SearchResultHitDocument)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchResultHitDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchResultHitDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResultHitGeoDistanceMeters as json.
func (o OptSearchResultHitGeoDistanceMeters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchResultHitGeoDistanceMeters from json.
func (o *OptSearchResultHitGeoDistanceMeters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchResultHitGeoDistanceMeters to nil")
	}
	o.Set = true
	o.Value = make(SearchResultHitGeoDistanceMeters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchResultHitGeoDistanceMeters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchResultHitGeoDistanceMeters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResultHitHighlight as json.
func (o OptSearchResultHitHighlight) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchResultHitHighlight from json.
func (o *OptSearchResultHitHighlight) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchResultHitHighlight to nil")
	}
	o.Set = true
	o.Value = make(SearchResultHitHighlight)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchResultHitHighlight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchResultHitHighlight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResultHitHybridSearchInfo as json.
func (o OptSearchResultHitHybridSearchInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchResultHitHybridSearchInfo from json.
func (o *OptSearchResultHitHybridSearchInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchResultHitHybridSearchInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchResultHitHybridSearchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchResultHitHybridSearchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResultHitTextMatchInfo as json.
func (o OptSearchResultHitTextMatchInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchResultHitTextMatchInfo from json.
func (o *OptSearchResultHitTextMatchInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchResultHitTextMatchInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchResultHitTextMatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchResultHitTextMatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceQueryModelCollectionConfig as json.
func (o OptVoiceQueryModelCollectionConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceQueryModelCollectionConfig from json.
func (o *OptVoiceQueryModelCollectionConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceQueryModelCollectionConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceQueryModelCollectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceQueryModelCollectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PresetDeleteSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PresetDeleteSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfPresetDeleteSchema = [1]string{
	0: "name",
}

// Decode decodes PresetDeleteSchema from json.
func (s *PresetDeleteSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresetDeleteSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PresetDeleteSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPresetDeleteSchema) {
					name = jsonFieldsNameOfPresetDeleteSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PresetDeleteSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresetDeleteSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PresetSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PresetSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfPresetSchema = [2]string{
	0: "value",
	1: "name",
}

// Decode decodes PresetSchema from json.
func (s *PresetSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresetSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PresetSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPresetSchema) {
					name = jsonFieldsNameOfPresetSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PresetSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresetSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PresetSchemaValue as json.
func (s PresetSchemaValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case SearchParametersPresetSchemaValue:
		s.SearchParameters.Encode(e)
	case MultiSearchSearchesParameterPresetSchemaValue:
		s.MultiSearchSearchesParameter.Encode(e)
	}
}

func (s PresetSchemaValue) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case SearchParametersPresetSchemaValue:
		s.SearchParameters.encodeFields(e)
	case MultiSearchSearchesParameterPresetSchemaValue:
		s.MultiSearchSearchesParameter.encodeFields(e)
	}
}

// Decode decodes PresetSchemaValue from json.
func (s *PresetSchemaValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresetSchemaValue to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "q":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "query_by":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "nl_query":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "nl_model_id":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "query_by_weights":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "text_match_type":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prefix":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "infix":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_extra_prefix":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_extra_suffix":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "filter_by":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_filter_by_candidates":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sort_by":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_by":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_facet_values":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_query":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "num_typos":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "page":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "per_page":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "limit":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "offset":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "group_by":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "group_limit":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "group_missing_values":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "include_fields":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exclude_fields":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_full_fields":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_affix_num_tokens":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_start_tag":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_end_tag":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_highlight_v1":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "snippet_threshold":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "drop_tokens_threshold":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "drop_tokens_mode":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "typo_tokens_threshold":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_typos_for_alpha_numerical_tokens":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "filter_curated_hits":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_synonyms":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "synonym_prefix":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "synonym_num_typos":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "pinned_hits":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "hidden_hits":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "override_tags":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_fields":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "split_join_tokens":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "pre_segmented_query":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "preset":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_overrides":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prioritize_exact_match":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_candidates":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prioritize_token_position":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prioritize_num_matching_fields":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_typos_for_numerical_tokens":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exhaustive_search":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "search_cutoff_ms":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "use_cache":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "cache_ttl":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "min_len_1typo":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "min_len_2typo":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "vector_query":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remote_embedding_timeout_ms":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remote_embedding_num_tries":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_strategy":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "stopwords":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_return_parent":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "voice_query":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "conversation":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "conversation_model_id":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "conversation_id":
				match := SearchParametersPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "union":
				match := MultiSearchSearchesParameterPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "searches":
				match := MultiSearchSearchesParameterPresetSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case SearchParametersPresetSchemaValue:
		if err := s.SearchParameters.Decode(d); err != nil {
			return err
		}
	case MultiSearchSearchesParameterPresetSchemaValue:
		if err := s.MultiSearchSearchesParameter.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PresetSchemaValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresetSchemaValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PresetUpsertSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PresetUpsertSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfPresetUpsertSchema = [1]string{
	0: "value",
}

// Decode decodes PresetUpsertSchema from json.
func (s *PresetUpsertSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresetUpsertSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PresetUpsertSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPresetUpsertSchema) {
					name = jsonFieldsNameOfPresetUpsertSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PresetUpsertSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresetUpsertSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PresetUpsertSchemaValue as json.
func (s PresetUpsertSchemaValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case SearchParametersPresetUpsertSchemaValue:
		s.SearchParameters.Encode(e)
	case MultiSearchSearchesParameterPresetUpsertSchemaValue:
		s.MultiSearchSearchesParameter.Encode(e)
	}
}

func (s PresetUpsertSchemaValue) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case SearchParametersPresetUpsertSchemaValue:
		s.SearchParameters.encodeFields(e)
	case MultiSearchSearchesParameterPresetUpsertSchemaValue:
		s.MultiSearchSearchesParameter.encodeFields(e)
	}
}

// Decode decodes PresetUpsertSchemaValue from json.
func (s *PresetUpsertSchemaValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresetUpsertSchemaValue to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "q":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "query_by":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "nl_query":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "nl_model_id":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "query_by_weights":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "text_match_type":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prefix":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "infix":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_extra_prefix":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_extra_suffix":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "filter_by":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_filter_by_candidates":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sort_by":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_by":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_facet_values":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_query":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "num_typos":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "page":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "per_page":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "limit":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "offset":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "group_by":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "group_limit":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "group_missing_values":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "include_fields":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exclude_fields":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_full_fields":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_affix_num_tokens":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_start_tag":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_end_tag":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_highlight_v1":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "snippet_threshold":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "drop_tokens_threshold":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "drop_tokens_mode":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "typo_tokens_threshold":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_typos_for_alpha_numerical_tokens":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "filter_curated_hits":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_synonyms":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "synonym_prefix":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "synonym_num_typos":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "pinned_hits":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "hidden_hits":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "override_tags":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "highlight_fields":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "split_join_tokens":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "pre_segmented_query":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "preset":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_overrides":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prioritize_exact_match":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_candidates":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prioritize_token_position":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prioritize_num_matching_fields":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "enable_typos_for_numerical_tokens":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exhaustive_search":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "search_cutoff_ms":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "use_cache":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "cache_ttl":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "min_len_1typo":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "min_len_2typo":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "vector_query":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remote_embedding_timeout_ms":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remote_embedding_num_tries":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_strategy":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "stopwords":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "facet_return_parent":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "voice_query":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "conversation":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "conversation_model_id":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "conversation_id":
				match := SearchParametersPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "union":
				match := MultiSearchSearchesParameterPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "searches":
				match := MultiSearchSearchesParameterPresetUpsertSchemaValue
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case SearchParametersPresetUpsertSchemaValue:
		if err := s.SearchParameters.Decode(d); err != nil {
			return err
		}
	case MultiSearchSearchesParameterPresetUpsertSchemaValue:
		if err := s.MultiSearchSearchesParameter.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PresetUpsertSchemaValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresetUpsertSchemaValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PresetsRetrieveSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PresetsRetrieveSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("presets")
		e.ArrStart()
		for _, elem := range s.Presets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPresetsRetrieveSchema = [1]string{
	0: "presets",
}

// Decode decodes PresetsRetrieveSchema from json.
func (s *PresetsRetrieveSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresetsRetrieveSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "presets":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Presets = make([]PresetSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PresetSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Presets = append(s.Presets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PresetsRetrieveSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPresetsRetrieveSchema) {
					name = jsonFieldsNameOfPresetsRetrieveSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PresetsRetrieveSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresetsRetrieveSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveMetricsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveMetricsOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRetrieveMetricsOK = [0]string{}

// Decode decodes RetrieveMetricsOK from json.
func (s *RetrieveMetricsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveMetricsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveMetricsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveMetricsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveMetricsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SchemaChangeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SchemaChangeStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Collection.Set {
			e.FieldStart("collection")
			s.Collection.Encode(e)
		}
	}
	{
		if s.ValidatedDocs.Set {
			e.FieldStart("validated_docs")
			s.ValidatedDocs.Encode(e)
		}
	}
	{
		if s.AlteredDocs.Set {
			e.FieldStart("altered_docs")
			s.AlteredDocs.Encode(e)
		}
	}
}

var jsonFieldsNameOfSchemaChangeStatus = [3]string{
	0: "collection",
	1: "validated_docs",
	2: "altered_docs",
}

// Decode decodes SchemaChangeStatus from json.
func (s *SchemaChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaChangeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collection":
			if err := func() error {
				s.Collection.Reset()
				if err := s.Collection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collection\"")
			}
		case "validated_docs":
			if err := func() error {
				s.ValidatedDocs.Reset()
				if err := s.ValidatedDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validated_docs\"")
			}
		case "altered_docs":
			if err := func() error {
				s.AlteredDocs.Reset()
				if err := s.AlteredDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"altered_docs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SchemaChangeStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SchemaChangeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaChangeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchCollectionBadRequest as json.
func (s *SearchCollectionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchCollectionBadRequest from json.
func (s *SearchCollectionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCollectionBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchCollectionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchCollectionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchCollectionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchCollectionNotFound as json.
func (s *SearchCollectionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchCollectionNotFound from json.
func (s *SearchCollectionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCollectionNotFound to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchCollectionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchCollectionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchCollectionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchGroupedHit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchGroupedHit) encodeFields(e *jx.Encoder) {
	{
		if s.Found.Set {
			e.FieldStart("found")
			s.Found.Encode(e)
		}
	}
	{
		e.FieldStart("group_key")
		e.ArrStart()
		for _, elem := range s.GroupKey {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hits")
		e.ArrStart()
		for _, elem := range s.Hits {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchGroupedHit = [3]string{
	0: "found",
	1: "group_key",
	2: "hits",
}

// Decode decodes SearchGroupedHit from json.
func (s *SearchGroupedHit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchGroupedHit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "found":
			if err := func() error {
				s.Found.Reset()
				if err := s.Found.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"found\"")
			}
		case "group_key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.GroupKey = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.GroupKey = append(s.GroupKey, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_key\"")
			}
		case "hits":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Hits = make([]SearchResultHit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultHit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hits = append(s.Hits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchGroupedHit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchGroupedHit) {
					name = jsonFieldsNameOfSearchGroupedHit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchGroupedHit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchGroupedHit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchHighlight) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchHighlight) encodeFields(e *jx.Encoder) {
	{
		if s.Field.Set {
			e.FieldStart("field")
			s.Field.Encode(e)
		}
	}
	{
		if s.Snippet.Set {
			e.FieldStart("snippet")
			s.Snippet.Encode(e)
		}
	}
	{
		if s.Snippets != nil {
			e.FieldStart("snippets")
			e.ArrStart()
			for _, elem := range s.Snippets {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Indices != nil {
			e.FieldStart("indices")
			e.ArrStart()
			for _, elem := range s.Indices {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchedTokens != nil {
			e.FieldStart("matched_tokens")
			e.ArrStart()
			for _, elem := range s.MatchedTokens {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSearchHighlight = [7]string{
	0: "field",
	1: "snippet",
	2: "snippets",
	3: "value",
	4: "values",
	5: "indices",
	6: "matched_tokens",
}

// Decode decodes SearchHighlight from json.
func (s *SearchHighlight) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchHighlight to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		case "snippet":
			if err := func() error {
				s.Snippet.Reset()
				if err := s.Snippet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet\"")
			}
		case "snippets":
			if err := func() error {
				s.Snippets = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Snippets = append(s.Snippets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippets\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		case "indices":
			if err := func() error {
				s.Indices = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Indices = append(s.Indices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indices\"")
			}
		case "matched_tokens":
			if err := func() error {
				s.MatchedTokens = make([]SearchHighlightMatchedTokensItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchHighlightMatchedTokensItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchedTokens = append(s.MatchedTokens, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matched_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchHighlight")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchHighlight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchHighlight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchHighlightMatchedTokensItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchHighlightMatchedTokensItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSearchHighlightMatchedTokensItem = [0]string{}

// Decode decodes SearchHighlightMatchedTokensItem from json.
func (s *SearchHighlightMatchedTokensItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchHighlightMatchedTokensItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SearchHighlightMatchedTokensItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchHighlightMatchedTokensItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchHighlightMatchedTokensItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverride) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rule")
		s.Rule.Encode(e)
	}
	{
		if s.Includes != nil {
			e.FieldStart("includes")
			e.ArrStart()
			for _, elem := range s.Includes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Excludes != nil {
			e.FieldStart("excludes")
			e.ArrStart()
			for _, elem := range s.Excludes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FilterBy.Set {
			e.FieldStart("filter_by")
			s.FilterBy.Encode(e)
		}
	}
	{
		if s.RemoveMatchedTokens.Set {
			e.FieldStart("remove_matched_tokens")
			s.RemoveMatchedTokens.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.SortBy.Set {
			e.FieldStart("sort_by")
			s.SortBy.Encode(e)
		}
	}
	{
		if s.ReplaceQuery.Set {
			e.FieldStart("replace_query")
			s.ReplaceQuery.Encode(e)
		}
	}
	{
		if s.FilterCuratedHits.Set {
			e.FieldStart("filter_curated_hits")
			s.FilterCuratedHits.Encode(e)
		}
	}
	{
		if s.EffectiveFromTs.Set {
			e.FieldStart("effective_from_ts")
			s.EffectiveFromTs.Encode(e)
		}
	}
	{
		if s.EffectiveToTs.Set {
			e.FieldStart("effective_to_ts")
			s.EffectiveToTs.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfSearchOverride = [13]string{
	0:  "rule",
	1:  "includes",
	2:  "excludes",
	3:  "filter_by",
	4:  "remove_matched_tokens",
	5:  "metadata",
	6:  "sort_by",
	7:  "replace_query",
	8:  "filter_curated_hits",
	9:  "effective_from_ts",
	10: "effective_to_ts",
	11: "stop_processing",
	12: "id",
}

// Decode decodes SearchOverride from json.
func (s *SearchOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverride to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "includes":
			if err := func() error {
				s.Includes = make([]SearchOverrideInclude, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchOverrideInclude
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Includes = append(s.Includes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includes\"")
			}
		case "excludes":
			if err := func() error {
				s.Excludes = make([]SearchOverrideExclude, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchOverrideExclude
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Excludes = append(s.Excludes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludes\"")
			}
		case "filter_by":
			if err := func() error {
				s.FilterBy.Reset()
				if err := s.FilterBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_by\"")
			}
		case "remove_matched_tokens":
			if err := func() error {
				s.RemoveMatchedTokens.Reset()
				if err := s.RemoveMatchedTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_matched_tokens\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem SearchOverrideMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "sort_by":
			if err := func() error {
				s.SortBy.Reset()
				if err := s.SortBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort_by\"")
			}
		case "replace_query":
			if err := func() error {
				s.ReplaceQuery.Reset()
				if err := s.ReplaceQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replace_query\"")
			}
		case "filter_curated_hits":
			if err := func() error {
				s.FilterCuratedHits.Reset()
				if err := s.FilterCuratedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_curated_hits\"")
			}
		case "effective_from_ts":
			if err := func() error {
				s.EffectiveFromTs.Reset()
				if err := s.EffectiveFromTs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_from_ts\"")
			}
		case "effective_to_ts":
			if err := func() error {
				s.EffectiveToTs.Reset()
				if err := s.EffectiveToTs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_to_ts\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverride")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchOverride) {
					name = jsonFieldsNameOfSearchOverride[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverrideDeleteResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverrideDeleteResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfSearchOverrideDeleteResponse = [1]string{
	0: "id",
}

// Decode decodes SearchOverrideDeleteResponse from json.
func (s *SearchOverrideDeleteResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideDeleteResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverrideDeleteResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchOverrideDeleteResponse) {
					name = jsonFieldsNameOfSearchOverrideDeleteResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverrideDeleteResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideDeleteResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverrideExclude) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverrideExclude) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfSearchOverrideExclude = [1]string{
	0: "id",
}

// Decode decodes SearchOverrideExclude from json.
func (s *SearchOverrideExclude) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideExclude to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverrideExclude")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchOverrideExclude) {
					name = jsonFieldsNameOfSearchOverrideExclude[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverrideExclude) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideExclude) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverrideInclude) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverrideInclude) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
}

var jsonFieldsNameOfSearchOverrideInclude = [2]string{
	0: "id",
	1: "position",
}

// Decode decodes SearchOverrideInclude from json.
func (s *SearchOverrideInclude) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideInclude to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverrideInclude")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchOverrideInclude) {
					name = jsonFieldsNameOfSearchOverrideInclude[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverrideInclude) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideInclude) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverrideMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverrideMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSearchOverrideMetadata = [0]string{}

// Decode decodes SearchOverrideMetadata from json.
func (s *SearchOverrideMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverrideMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverrideMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverrideRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverrideRule) encodeFields(e *jx.Encoder) {
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
	{
		if s.Match.Set {
			e.FieldStart("match")
			s.Match.Encode(e)
		}
	}
	{
		if s.FilterBy.Set {
			e.FieldStart("filter_by")
			s.FilterBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchOverrideRule = [4]string{
	0: "tags",
	1: "query",
	2: "match",
	3: "filter_by",
}

// Decode decodes SearchOverrideRule from json.
func (s *SearchOverrideRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "match":
			if err := func() error {
				s.Match.Reset()
				if err := s.Match.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"match\"")
			}
		case "filter_by":
			if err := func() error {
				s.FilterBy.Reset()
				if err := s.FilterBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverrideRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverrideRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchOverrideRuleMatch as json.
func (s SearchOverrideRuleMatch) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchOverrideRuleMatch from json.
func (s *SearchOverrideRuleMatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideRuleMatch to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchOverrideRuleMatch(v) {
	case SearchOverrideRuleMatchExact:
		*s = SearchOverrideRuleMatchExact
	case SearchOverrideRuleMatchContains:
		*s = SearchOverrideRuleMatchContains
	default:
		*s = SearchOverrideRuleMatch(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchOverrideRuleMatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideRuleMatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverrideSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverrideSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rule")
		s.Rule.Encode(e)
	}
	{
		if s.Includes != nil {
			e.FieldStart("includes")
			e.ArrStart()
			for _, elem := range s.Includes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Excludes != nil {
			e.FieldStart("excludes")
			e.ArrStart()
			for _, elem := range s.Excludes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FilterBy.Set {
			e.FieldStart("filter_by")
			s.FilterBy.Encode(e)
		}
	}
	{
		if s.RemoveMatchedTokens.Set {
			e.FieldStart("remove_matched_tokens")
			s.RemoveMatchedTokens.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.SortBy.Set {
			e.FieldStart("sort_by")
			s.SortBy.Encode(e)
		}
	}
	{
		if s.ReplaceQuery.Set {
			e.FieldStart("replace_query")
			s.ReplaceQuery.Encode(e)
		}
	}
	{
		if s.FilterCuratedHits.Set {
			e.FieldStart("filter_curated_hits")
			s.FilterCuratedHits.Encode(e)
		}
	}
	{
		if s.EffectiveFromTs.Set {
			e.FieldStart("effective_from_ts")
			s.EffectiveFromTs.Encode(e)
		}
	}
	{
		if s.EffectiveToTs.Set {
			e.FieldStart("effective_to_ts")
			s.EffectiveToTs.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchOverrideSchema = [12]string{
	0:  "rule",
	1:  "includes",
	2:  "excludes",
	3:  "filter_by",
	4:  "remove_matched_tokens",
	5:  "metadata",
	6:  "sort_by",
	7:  "replace_query",
	8:  "filter_curated_hits",
	9:  "effective_from_ts",
	10: "effective_to_ts",
	11: "stop_processing",
}

// Decode decodes SearchOverrideSchema from json.
func (s *SearchOverrideSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "includes":
			if err := func() error {
				s.Includes = make([]SearchOverrideInclude, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchOverrideInclude
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Includes = append(s.Includes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includes\"")
			}
		case "excludes":
			if err := func() error {
				s.Excludes = make([]SearchOverrideExclude, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchOverrideExclude
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Excludes = append(s.Excludes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludes\"")
			}
		case "filter_by":
			if err := func() error {
				s.FilterBy.Reset()
				if err := s.FilterBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_by\"")
			}
		case "remove_matched_tokens":
			if err := func() error {
				s.RemoveMatchedTokens.Reset()
				if err := s.RemoveMatchedTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_matched_tokens\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem SearchOverrideSchemaMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "sort_by":
			if err := func() error {
				s.SortBy.Reset()
				if err := s.SortBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort_by\"")
			}
		case "replace_query":
			if err := func() error {
				s.ReplaceQuery.Reset()
				if err := s.ReplaceQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replace_query\"")
			}
		case "filter_curated_hits":
			if err := func() error {
				s.FilterCuratedHits.Reset()
				if err := s.FilterCuratedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_curated_hits\"")
			}
		case "effective_from_ts":
			if err := func() error {
				s.EffectiveFromTs.Reset()
				if err := s.EffectiveFromTs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_from_ts\"")
			}
		case "effective_to_ts":
			if err := func() error {
				s.EffectiveToTs.Reset()
				if err := s.EffectiveToTs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_to_ts\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverrideSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchOverrideSchema) {
					name = jsonFieldsNameOfSearchOverrideSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverrideSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverrideSchemaMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverrideSchemaMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSearchOverrideSchemaMetadata = [0]string{}

// Decode decodes SearchOverrideSchemaMetadata from json.
func (s *SearchOverrideSchemaMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverrideSchemaMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverrideSchemaMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverrideSchemaMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverrideSchemaMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchOverridesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchOverridesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("overrides")
		e.ArrStart()
		for _, elem := range s.Overrides {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchOverridesResponse = [1]string{
	0: "overrides",
}

// Decode decodes SearchOverridesResponse from json.
func (s *SearchOverridesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchOverridesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "overrides":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Overrides = make([]SearchOverride, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchOverride
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Overrides = append(s.Overrides, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrides\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchOverridesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchOverridesResponse) {
					name = jsonFieldsNameOfSearchOverridesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchOverridesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchOverridesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchParameters) encodeFields(e *jx.Encoder) {
	{
		if s.Q.Set {
			e.FieldStart("q")
			s.Q.Encode(e)
		}
	}
	{
		if s.QueryBy.Set {
			e.FieldStart("query_by")
			s.QueryBy.Encode(e)
		}
	}
	{
		if s.NlQuery.Set {
			e.FieldStart("nl_query")
			s.NlQuery.Encode(e)
		}
	}
	{
		if s.NlModelID.Set {
			e.FieldStart("nl_model_id")
			s.NlModelID.Encode(e)
		}
	}
	{
		if s.QueryByWeights.Set {
			e.FieldStart("query_by_weights")
			s.QueryByWeights.Encode(e)
		}
	}
	{
		if s.TextMatchType.Set {
			e.FieldStart("text_match_type")
			s.TextMatchType.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.Infix.Set {
			e.FieldStart("infix")
			s.Infix.Encode(e)
		}
	}
	{
		if s.MaxExtraPrefix.Set {
			e.FieldStart("max_extra_prefix")
			s.MaxExtraPrefix.Encode(e)
		}
	}
	{
		if s.MaxExtraSuffix.Set {
			e.FieldStart("max_extra_suffix")
			s.MaxExtraSuffix.Encode(e)
		}
	}
	{
		if s.FilterBy.Set {
			e.FieldStart("filter_by")
			s.FilterBy.Encode(e)
		}
	}
	{
		if s.MaxFilterByCandidates.Set {
			e.FieldStart("max_filter_by_candidates")
			s.MaxFilterByCandidates.Encode(e)
		}
	}
	{
		if s.SortBy.Set {
			e.FieldStart("sort_by")
			s.SortBy.Encode(e)
		}
	}
	{
		if s.FacetBy.Set {
			e.FieldStart("facet_by")
			s.FacetBy.Encode(e)
		}
	}
	{
		if s.MaxFacetValues.Set {
			e.FieldStart("max_facet_values")
			s.MaxFacetValues.Encode(e)
		}
	}
	{
		if s.FacetQuery.Set {
			e.FieldStart("facet_query")
			s.FacetQuery.Encode(e)
		}
	}
	{
		if s.NumTypos.Set {
			e.FieldStart("num_typos")
			s.NumTypos.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PerPage.Set {
			e.FieldStart("per_page")
			s.PerPage.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.GroupBy.Set {
			e.FieldStart("group_by")
			s.GroupBy.Encode(e)
		}
	}
	{
		if s.GroupLimit.Set {
			e.FieldStart("group_limit")
			s.GroupLimit.Encode(e)
		}
	}
	{
		if s.GroupMissingValues.Set {
			e.FieldStart("group_missing_values")
			s.GroupMissingValues.Encode(e)
		}
	}
	{
		if s.IncludeFields.Set {
			e.FieldStart("include_fields")
			s.IncludeFields.Encode(e)
		}
	}
	{
		if s.ExcludeFields.Set {
			e.FieldStart("exclude_fields")
			s.ExcludeFields.Encode(e)
		}
	}
	{
		if s.HighlightFullFields.Set {
			e.FieldStart("highlight_full_fields")
			s.HighlightFullFields.Encode(e)
		}
	}
	{
		if s.HighlightAffixNumTokens.Set {
			e.FieldStart("highlight_affix_num_tokens")
			s.HighlightAffixNumTokens.Encode(e)
		}
	}
	{
		if s.HighlightStartTag.Set {
			e.FieldStart("highlight_start_tag")
			s.HighlightStartTag.Encode(e)
		}
	}
	{
		if s.HighlightEndTag.Set {
			e.FieldStart("highlight_end_tag")
			s.HighlightEndTag.Encode(e)
		}
	}
	{
		if s.EnableHighlightV1.Set {
			e.FieldStart("enable_highlight_v1")
			s.EnableHighlightV1.Encode(e)
		}
	}
	{
		if s.SnippetThreshold.Set {
			e.FieldStart("snippet_threshold")
			s.SnippetThreshold.Encode(e)
		}
	}
	{
		if s.DropTokensThreshold.Set {
			e.FieldStart("drop_tokens_threshold")
			s.DropTokensThreshold.Encode(e)
		}
	}
	{
		if s.DropTokensMode.Set {
			e.FieldStart("drop_tokens_mode")
			s.DropTokensMode.Encode(e)
		}
	}
	{
		if s.TypoTokensThreshold.Set {
			e.FieldStart("typo_tokens_threshold")
			s.TypoTokensThreshold.Encode(e)
		}
	}
	{
		if s.EnableTyposForAlphaNumericalTokens.Set {
			e.FieldStart("enable_typos_for_alpha_numerical_tokens")
			s.EnableTyposForAlphaNumericalTokens.Encode(e)
		}
	}
	{
		if s.FilterCuratedHits.Set {
			e.FieldStart("filter_curated_hits")
			s.FilterCuratedHits.Encode(e)
		}
	}
	{
		if s.EnableSynonyms.Set {
			e.FieldStart("enable_synonyms")
			s.EnableSynonyms.Encode(e)
		}
	}
	{
		if s.SynonymPrefix.Set {
			e.FieldStart("synonym_prefix")
			s.SynonymPrefix.Encode(e)
		}
	}
	{
		if s.SynonymNumTypos.Set {
			e.FieldStart("synonym_num_typos")
			s.SynonymNumTypos.Encode(e)
		}
	}
	{
		if s.PinnedHits.Set {
			e.FieldStart("pinned_hits")
			s.PinnedHits.Encode(e)
		}
	}
	{
		if s.HiddenHits.Set {
			e.FieldStart("hidden_hits")
			s.HiddenHits.Encode(e)
		}
	}
	{
		if s.OverrideTags.Set {
			e.FieldStart("override_tags")
			s.OverrideTags.Encode(e)
		}
	}
	{
		if s.HighlightFields.Set {
			e.FieldStart("highlight_fields")
			s.HighlightFields.Encode(e)
		}
	}
	{
		if s.SplitJoinTokens.Set {
			e.FieldStart("split_join_tokens")
			s.SplitJoinTokens.Encode(e)
		}
	}
	{
		if s.PreSegmentedQuery.Set {
			e.FieldStart("pre_segmented_query")
			s.PreSegmentedQuery.Encode(e)
		}
	}
	{
		if s.Preset.Set {
			e.FieldStart("preset")
			s.Preset.Encode(e)
		}
	}
	{
		if s.EnableOverrides.Set {
			e.FieldStart("enable_overrides")
			s.EnableOverrides.Encode(e)
		}
	}
	{
		if s.PrioritizeExactMatch.Set {
			e.FieldStart("prioritize_exact_match")
			s.PrioritizeExactMatch.Encode(e)
		}
	}
	{
		if s.MaxCandidates.Set {
			e.FieldStart("max_candidates")
			s.MaxCandidates.Encode(e)
		}
	}
	{
		if s.PrioritizeTokenPosition.Set {
			e.FieldStart("prioritize_token_position")
			s.PrioritizeTokenPosition.Encode(e)
		}
	}
	{
		if s.PrioritizeNumMatchingFields.Set {
			e.FieldStart("prioritize_num_matching_fields")
			s.PrioritizeNumMatchingFields.Encode(e)
		}
	}
	{
		if s.EnableTyposForNumericalTokens.Set {
			e.FieldStart("enable_typos_for_numerical_tokens")
			s.EnableTyposForNumericalTokens.Encode(e)
		}
	}
	{
		if s.ExhaustiveSearch.Set {
			e.FieldStart("exhaustive_search")
			s.ExhaustiveSearch.Encode(e)
		}
	}
	{
		if s.SearchCutoffMs.Set {
			e.FieldStart("search_cutoff_ms")
			s.SearchCutoffMs.Encode(e)
		}
	}
	{
		if s.UseCache.Set {
			e.FieldStart("use_cache")
			s.UseCache.Encode(e)
		}
	}
	{
		if s.CacheTTL.Set {
			e.FieldStart("cache_ttl")
			s.CacheTTL.Encode(e)
		}
	}
	{
		if s.MinLen1typo.Set {
			e.FieldStart("min_len_1typo")
			s.MinLen1typo.Encode(e)
		}
	}
	{
		if s.MinLen2typo.Set {
			e.FieldStart("min_len_2typo")
			s.MinLen2typo.Encode(e)
		}
	}
	{
		if s.VectorQuery.Set {
			e.FieldStart("vector_query")
			s.VectorQuery.Encode(e)
		}
	}
	{
		if s.RemoteEmbeddingTimeoutMs.Set {
			e.FieldStart("remote_embedding_timeout_ms")
			s.RemoteEmbeddingTimeoutMs.Encode(e)
		}
	}
	{
		if s.RemoteEmbeddingNumTries.Set {
			e.FieldStart("remote_embedding_num_tries")
			s.RemoteEmbeddingNumTries.Encode(e)
		}
	}
	{
		if s.FacetStrategy.Set {
			e.FieldStart("facet_strategy")
			s.FacetStrategy.Encode(e)
		}
	}
	{
		if s.Stopwords.Set {
			e.FieldStart("stopwords")
			s.Stopwords.Encode(e)
		}
	}
	{
		if s.FacetReturnParent.Set {
			e.FieldStart("facet_return_parent")
			s.FacetReturnParent.Encode(e)
		}
	}
	{
		if s.VoiceQuery.Set {
			e.FieldStart("voice_query")
			s.VoiceQuery.Encode(e)
		}
	}
	{
		if s.Conversation.Set {
			e.FieldStart("conversation")
			s.Conversation.Encode(e)
		}
	}
	{
		if s.ConversationModelID.Set {
			e.FieldStart("conversation_model_id")
			s.ConversationModelID.Encode(e)
		}
	}
	{
		if s.ConversationID.Set {
			e.FieldStart("conversation_id")
			s.ConversationID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchParameters = [69]string{
	0:  "q",
	1:  "query_by",
	2:  "nl_query",
	3:  "nl_model_id",
	4:  "query_by_weights",
	5:  "text_match_type",
	6:  "prefix",
	7:  "infix",
	8:  "max_extra_prefix",
	9:  "max_extra_suffix",
	10: "filter_by",
	11: "max_filter_by_candidates",
	12: "sort_by",
	13: "facet_by",
	14: "max_facet_values",
	15: "facet_query",
	16: "num_typos",
	17: "page",
	18: "per_page",
	19: "limit",
	20: "offset",
	21: "group_by",
	22: "group_limit",
	23: "group_missing_values",
	24: "include_fields",
	25: "exclude_fields",
	26: "highlight_full_fields",
	27: "highlight_affix_num_tokens",
	28: "highlight_start_tag",
	29: "highlight_end_tag",
	30: "enable_highlight_v1",
	31: "snippet_threshold",
	32: "drop_tokens_threshold",
	33: "drop_tokens_mode",
	34: "typo_tokens_threshold",
	35: "enable_typos_for_alpha_numerical_tokens",
	36: "filter_curated_hits",
	37: "enable_synonyms",
	38: "synonym_prefix",
	39: "synonym_num_typos",
	40: "pinned_hits",
	41: "hidden_hits",
	42: "override_tags",
	43: "highlight_fields",
	44: "split_join_tokens",
	45: "pre_segmented_query",
	46: "preset",
	47: "enable_overrides",
	48: "prioritize_exact_match",
	49: "max_candidates",
	50: "prioritize_token_position",
	51: "prioritize_num_matching_fields",
	52: "enable_typos_for_numerical_tokens",
	53: "exhaustive_search",
	54: "search_cutoff_ms",
	55: "use_cache",
	56: "cache_ttl",
	57: "min_len_1typo",
	58: "min_len_2typo",
	59: "vector_query",
	60: "remote_embedding_timeout_ms",
	61: "remote_embedding_num_tries",
	62: "facet_strategy",
	63: "stopwords",
	64: "facet_return_parent",
	65: "voice_query",
	66: "conversation",
	67: "conversation_model_id",
	68: "conversation_id",
}

// Decode decodes SearchParameters from json.
func (s *SearchParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchParameters to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "q":
			if err := func() error {
				s.Q.Reset()
				if err := s.Q.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"q\"")
			}
		case "query_by":
			if err := func() error {
				s.QueryBy.Reset()
				if err := s.QueryBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_by\"")
			}
		case "nl_query":
			if err := func() error {
				s.NlQuery.Reset()
				if err := s.NlQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nl_query\"")
			}
		case "nl_model_id":
			if err := func() error {
				s.NlModelID.Reset()
				if err := s.NlModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nl_model_id\"")
			}
		case "query_by_weights":
			if err := func() error {
				s.QueryByWeights.Reset()
				if err := s.QueryByWeights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_by_weights\"")
			}
		case "text_match_type":
			if err := func() error {
				s.TextMatchType.Reset()
				if err := s.TextMatchType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_match_type\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "infix":
			if err := func() error {
				s.Infix.Reset()
				if err := s.Infix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"infix\"")
			}
		case "max_extra_prefix":
			if err := func() error {
				s.MaxExtraPrefix.Reset()
				if err := s.MaxExtraPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_extra_prefix\"")
			}
		case "max_extra_suffix":
			if err := func() error {
				s.MaxExtraSuffix.Reset()
				if err := s.MaxExtraSuffix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_extra_suffix\"")
			}
		case "filter_by":
			if err := func() error {
				s.FilterBy.Reset()
				if err := s.FilterBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_by\"")
			}
		case "max_filter_by_candidates":
			if err := func() error {
				s.MaxFilterByCandidates.Reset()
				if err := s.MaxFilterByCandidates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_filter_by_candidates\"")
			}
		case "sort_by":
			if err := func() error {
				s.SortBy.Reset()
				if err := s.SortBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort_by\"")
			}
		case "facet_by":
			if err := func() error {
				s.FacetBy.Reset()
				if err := s.FacetBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_by\"")
			}
		case "max_facet_values":
			if err := func() error {
				s.MaxFacetValues.Reset()
				if err := s.MaxFacetValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_facet_values\"")
			}
		case "facet_query":
			if err := func() error {
				s.FacetQuery.Reset()
				if err := s.FacetQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_query\"")
			}
		case "num_typos":
			if err := func() error {
				s.NumTypos.Reset()
				if err := s.NumTypos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_typos\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "per_page":
			if err := func() error {
				s.PerPage.Reset()
				if err := s.PerPage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"per_page\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "group_by":
			if err := func() error {
				s.GroupBy.Reset()
				if err := s.GroupBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_by\"")
			}
		case "group_limit":
			if err := func() error {
				s.GroupLimit.Reset()
				if err := s.GroupLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_limit\"")
			}
		case "group_missing_values":
			if err := func() error {
				s.GroupMissingValues.Reset()
				if err := s.GroupMissingValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_missing_values\"")
			}
		case "include_fields":
			if err := func() error {
				s.IncludeFields.Reset()
				if err := s.IncludeFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_fields\"")
			}
		case "exclude_fields":
			if err := func() error {
				s.ExcludeFields.Reset()
				if err := s.ExcludeFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_fields\"")
			}
		case "highlight_full_fields":
			if err := func() error {
				s.HighlightFullFields.Reset()
				if err := s.HighlightFullFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_full_fields\"")
			}
		case "highlight_affix_num_tokens":
			if err := func() error {
				s.HighlightAffixNumTokens.Reset()
				if err := s.HighlightAffixNumTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_affix_num_tokens\"")
			}
		case "highlight_start_tag":
			if err := func() error {
				s.HighlightStartTag.Reset()
				if err := s.HighlightStartTag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_start_tag\"")
			}
		case "highlight_end_tag":
			if err := func() error {
				s.HighlightEndTag.Reset()
				if err := s.HighlightEndTag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_end_tag\"")
			}
		case "enable_highlight_v1":
			if err := func() error {
				s.EnableHighlightV1.Reset()
				if err := s.EnableHighlightV1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_highlight_v1\"")
			}
		case "snippet_threshold":
			if err := func() error {
				s.SnippetThreshold.Reset()
				if err := s.SnippetThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet_threshold\"")
			}
		case "drop_tokens_threshold":
			if err := func() error {
				s.DropTokensThreshold.Reset()
				if err := s.DropTokensThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_tokens_threshold\"")
			}
		case "drop_tokens_mode":
			if err := func() error {
				s.DropTokensMode.Reset()
				if err := s.DropTokensMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_tokens_mode\"")
			}
		case "typo_tokens_threshold":
			if err := func() error {
				s.TypoTokensThreshold.Reset()
				if err := s.TypoTokensThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typo_tokens_threshold\"")
			}
		case "enable_typos_for_alpha_numerical_tokens":
			if err := func() error {
				s.EnableTyposForAlphaNumericalTokens.Reset()
				if err := s.EnableTyposForAlphaNumericalTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_typos_for_alpha_numerical_tokens\"")
			}
		case "filter_curated_hits":
			if err := func() error {
				s.FilterCuratedHits.Reset()
				if err := s.FilterCuratedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_curated_hits\"")
			}
		case "enable_synonyms":
			if err := func() error {
				s.EnableSynonyms.Reset()
				if err := s.EnableSynonyms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_synonyms\"")
			}
		case "synonym_prefix":
			if err := func() error {
				s.SynonymPrefix.Reset()
				if err := s.SynonymPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonym_prefix\"")
			}
		case "synonym_num_typos":
			if err := func() error {
				s.SynonymNumTypos.Reset()
				if err := s.SynonymNumTypos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonym_num_typos\"")
			}
		case "pinned_hits":
			if err := func() error {
				s.PinnedHits.Reset()
				if err := s.PinnedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned_hits\"")
			}
		case "hidden_hits":
			if err := func() error {
				s.HiddenHits.Reset()
				if err := s.HiddenHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden_hits\"")
			}
		case "override_tags":
			if err := func() error {
				s.OverrideTags.Reset()
				if err := s.OverrideTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"override_tags\"")
			}
		case "highlight_fields":
			if err := func() error {
				s.HighlightFields.Reset()
				if err := s.HighlightFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight_fields\"")
			}
		case "split_join_tokens":
			if err := func() error {
				s.SplitJoinTokens.Reset()
				if err := s.SplitJoinTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"split_join_tokens\"")
			}
		case "pre_segmented_query":
			if err := func() error {
				s.PreSegmentedQuery.Reset()
				if err := s.PreSegmentedQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_segmented_query\"")
			}
		case "preset":
			if err := func() error {
				s.Preset.Reset()
				if err := s.Preset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preset\"")
			}
		case "enable_overrides":
			if err := func() error {
				s.EnableOverrides.Reset()
				if err := s.EnableOverrides.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_overrides\"")
			}
		case "prioritize_exact_match":
			if err := func() error {
				s.PrioritizeExactMatch.Reset()
				if err := s.PrioritizeExactMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prioritize_exact_match\"")
			}
		case "max_candidates":
			if err := func() error {
				s.MaxCandidates.Reset()
				if err := s.MaxCandidates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_candidates\"")
			}
		case "prioritize_token_position":
			if err := func() error {
				s.PrioritizeTokenPosition.Reset()
				if err := s.PrioritizeTokenPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prioritize_token_position\"")
			}
		case "prioritize_num_matching_fields":
			if err := func() error {
				s.PrioritizeNumMatchingFields.Reset()
				if err := s.PrioritizeNumMatchingFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prioritize_num_matching_fields\"")
			}
		case "enable_typos_for_numerical_tokens":
			if err := func() error {
				s.EnableTyposForNumericalTokens.Reset()
				if err := s.EnableTyposForNumericalTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_typos_for_numerical_tokens\"")
			}
		case "exhaustive_search":
			if err := func() error {
				s.ExhaustiveSearch.Reset()
				if err := s.ExhaustiveSearch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exhaustive_search\"")
			}
		case "search_cutoff_ms":
			if err := func() error {
				s.SearchCutoffMs.Reset()
				if err := s.SearchCutoffMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_cutoff_ms\"")
			}
		case "use_cache":
			if err := func() error {
				s.UseCache.Reset()
				if err := s.UseCache.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_cache\"")
			}
		case "cache_ttl":
			if err := func() error {
				s.CacheTTL.Reset()
				if err := s.CacheTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_ttl\"")
			}
		case "min_len_1typo":
			if err := func() error {
				s.MinLen1typo.Reset()
				if err := s.MinLen1typo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_len_1typo\"")
			}
		case "min_len_2typo":
			if err := func() error {
				s.MinLen2typo.Reset()
				if err := s.MinLen2typo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_len_2typo\"")
			}
		case "vector_query":
			if err := func() error {
				s.VectorQuery.Reset()
				if err := s.VectorQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vector_query\"")
			}
		case "remote_embedding_timeout_ms":
			if err := func() error {
				s.RemoteEmbeddingTimeoutMs.Reset()
				if err := s.RemoteEmbeddingTimeoutMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_embedding_timeout_ms\"")
			}
		case "remote_embedding_num_tries":
			if err := func() error {
				s.RemoteEmbeddingNumTries.Reset()
				if err := s.RemoteEmbeddingNumTries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_embedding_num_tries\"")
			}
		case "facet_strategy":
			if err := func() error {
				s.FacetStrategy.Reset()
				if err := s.FacetStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_strategy\"")
			}
		case "stopwords":
			if err := func() error {
				s.Stopwords.Reset()
				if err := s.Stopwords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopwords\"")
			}
		case "facet_return_parent":
			if err := func() error {
				s.FacetReturnParent.Reset()
				if err := s.FacetReturnParent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_return_parent\"")
			}
		case "voice_query":
			if err := func() error {
				s.VoiceQuery.Reset()
				if err := s.VoiceQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_query\"")
			}
		case "conversation":
			if err := func() error {
				s.Conversation.Reset()
				if err := s.Conversation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation\"")
			}
		case "conversation_model_id":
			if err := func() error {
				s.ConversationModelID.Reset()
				if err := s.ConversationModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_model_id\"")
			}
		case "conversation_id":
			if err := func() error {
				s.ConversationID.Reset()
				if err := s.ConversationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchRequestParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchRequestParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("collection_name")
		e.Str(s.CollectionName)
	}
	{
		e.FieldStart("q")
		e.Str(s.Q)
	}
	{
		e.FieldStart("per_page")
		e.Int(s.PerPage)
	}
	{
		if s.VoiceQuery.Set {
			e.FieldStart("voice_query")
			s.VoiceQuery.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchRequestParams = [4]string{
	0: "collection_name",
	1: "q",
	2: "per_page",
	3: "voice_query",
}

// Decode decodes SearchRequestParams from json.
func (s *SearchRequestParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRequestParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collection_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CollectionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collection_name\"")
			}
		case "q":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Q = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"q\"")
			}
		case "per_page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PerPage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"per_page\"")
			}
		case "voice_query":
			if err := func() error {
				s.VoiceQuery.Reset()
				if err := s.VoiceQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchRequestParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchRequestParams) {
					name = jsonFieldsNameOfSearchRequestParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchRequestParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRequestParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchRequestParamsVoiceQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchRequestParamsVoiceQuery) encodeFields(e *jx.Encoder) {
	{
		if s.TranscribedQuery.Set {
			e.FieldStart("transcribed_query")
			s.TranscribedQuery.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchRequestParamsVoiceQuery = [1]string{
	0: "transcribed_query",
}

// Decode decodes SearchRequestParamsVoiceQuery from json.
func (s *SearchRequestParamsVoiceQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRequestParamsVoiceQuery to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcribed_query":
			if err := func() error {
				s.TranscribedQuery.Reset()
				if err := s.TranscribedQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcribed_query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchRequestParamsVoiceQuery")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchRequestParamsVoiceQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRequestParamsVoiceQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResult) encodeFields(e *jx.Encoder) {
	{
		if s.FacetCounts != nil {
			e.FieldStart("facet_counts")
			e.ArrStart()
			for _, elem := range s.FacetCounts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Found.Set {
			e.FieldStart("found")
			s.Found.Encode(e)
		}
	}
	{
		if s.FoundDocs.Set {
			e.FieldStart("found_docs")
			s.FoundDocs.Encode(e)
		}
	}
	{
		if s.SearchTimeMs.Set {
			e.FieldStart("search_time_ms")
			s.SearchTimeMs.Encode(e)
		}
	}
	{
		if s.OutOf.Set {
			e.FieldStart("out_of")
			s.OutOf.Encode(e)
		}
	}
	{
		if s.SearchCutoff.Set {
			e.FieldStart("search_cutoff")
			s.SearchCutoff.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.GroupedHits != nil {
			e.FieldStart("grouped_hits")
			e.ArrStart()
			for _, elem := range s.GroupedHits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hits != nil {
			e.FieldStart("hits")
			e.ArrStart()
			for _, elem := range s.Hits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequestParams.Set {
			e.FieldStart("request_params")
			s.RequestParams.Encode(e)
		}
	}
	{
		if s.Conversation.Set {
			e.FieldStart("conversation")
			s.Conversation.Encode(e)
		}
	}
	{
		if s.UnionRequestParams != nil {
			e.FieldStart("union_request_params")
			e.ArrStart()
			for _, elem := range s.UnionRequestParams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSearchResult = [12]string{
	0:  "facet_counts",
	1:  "found",
	2:  "found_docs",
	3:  "search_time_ms",
	4:  "out_of",
	5:  "search_cutoff",
	6:  "page",
	7:  "grouped_hits",
	8:  "hits",
	9:  "request_params",
	10: "conversation",
	11: "union_request_params",
}

// Decode decodes SearchResult from json.
func (s *SearchResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "facet_counts":
			if err := func() error {
				s.FacetCounts = make([]FacetCounts, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FacetCounts
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FacetCounts = append(s.FacetCounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facet_counts\"")
			}
		case "found":
			if err := func() error {
				s.Found.Reset()
				if err := s.Found.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"found\"")
			}
		case "found_docs":
			if err := func() error {
				s.FoundDocs.Reset()
				if err := s.FoundDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"found_docs\"")
			}
		case "search_time_ms":
			if err := func() error {
				s.SearchTimeMs.Reset()
				if err := s.SearchTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_time_ms\"")
			}
		case "out_of":
			if err := func() error {
				s.OutOf.Reset()
				if err := s.OutOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"out_of\"")
			}
		case "search_cutoff":
			if err := func() error {
				s.SearchCutoff.Reset()
				if err := s.SearchCutoff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_cutoff\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "grouped_hits":
			if err := func() error {
				s.GroupedHits = make([]SearchGroupedHit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchGroupedHit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GroupedHits = append(s.GroupedHits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grouped_hits\"")
			}
		case "hits":
			if err := func() error {
				s.Hits = make([]SearchResultHit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultHit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hits = append(s.Hits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hits\"")
			}
		case "request_params":
			if err := func() error {
				s.RequestParams.Reset()
				if err := s.RequestParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_params\"")
			}
		case "conversation":
			if err := func() error {
				s.Conversation.Reset()
				if err := s.Conversation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation\"")
			}
		case "union_request_params":
			if err := func() error {
				s.UnionRequestParams = make([]SearchRequestParams, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchRequestParams
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UnionRequestParams = append(s.UnionRequestParams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"union_request_params\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultConversation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultConversation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("answer")
		e.Str(s.Answer)
	}
	{
		e.FieldStart("conversation_history")
		e.ArrStart()
		for _, elem := range s.ConversationHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("conversation_id")
		e.Str(s.ConversationID)
	}
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
}

var jsonFieldsNameOfSearchResultConversation = [4]string{
	0: "answer",
	1: "conversation_history",
	2: "conversation_id",
	3: "query",
}

// Decode decodes SearchResultConversation from json.
func (s *SearchResultConversation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultConversation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "answer":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Answer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answer\"")
			}
		case "conversation_history":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ConversationHistory = make([]SearchResultConversationConversationHistoryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultConversationConversationHistoryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ConversationHistory = append(s.ConversationHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_history\"")
			}
		case "conversation_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ConversationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultConversation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchResultConversation) {
					name = jsonFieldsNameOfSearchResultConversation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultConversation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultConversation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultConversationConversationHistoryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultConversationConversationHistoryItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSearchResultConversationConversationHistoryItem = [0]string{}

// Decode decodes SearchResultConversationConversationHistoryItem from json.
func (s *SearchResultConversationConversationHistoryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultConversationConversationHistoryItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultConversationConversationHistoryItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultConversationConversationHistoryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultConversationConversationHistoryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultHit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultHit) encodeFields(e *jx.Encoder) {
	{
		if s.Highlights != nil {
			e.FieldStart("highlights")
			e.ArrStart()
			for _, elem := range s.Highlights {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Highlight.Set {
			e.FieldStart("highlight")
			s.Highlight.Encode(e)
		}
	}
	{
		if s.Document.Set {
			e.FieldStart("document")
			s.Document.Encode(e)
		}
	}
	{
		if s.TextMatch.Set {
			e.FieldStart("text_match")
			s.TextMatch.Encode(e)
		}
	}
	{
		if s.TextMatchInfo.Set {
			e.FieldStart("text_match_info")
			s.TextMatchInfo.Encode(e)
		}
	}
	{
		if s.GeoDistanceMeters.Set {
			e.FieldStart("geo_distance_meters")
			s.GeoDistanceMeters.Encode(e)
		}
	}
	{
		if s.VectorDistance.Set {
			e.FieldStart("vector_distance")
			s.VectorDistance.Encode(e)
		}
	}
	{
		if s.HybridSearchInfo.Set {
			e.FieldStart("hybrid_search_info")
			s.HybridSearchInfo.Encode(e)
		}
	}
	{
		if s.SearchIndex.Set {
			e.FieldStart("search_index")
			s.SearchIndex.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchResultHit = [9]string{
	0: "highlights",
	1: "highlight",
	2: "document",
	3: "text_match",
	4: "text_match_info",
	5: "geo_distance_meters",
	6: "vector_distance",
	7: "hybrid_search_info",
	8: "search_index",
}

// Decode decodes SearchResultHit from json.
func (s *SearchResultHit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultHit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "highlights":
			if err := func() error {
				s.Highlights = make([]SearchHighlight, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchHighlight
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Highlights = append(s.Highlights, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlights\"")
			}
		case "highlight":
			if err := func() error {
				s.Highlight.Reset()
				if err := s.Highlight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlight\"")
			}
		case "document":
			if err := func() error {
				s.Document.Reset()
				if err := s.Document.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "text_match":
			if err := func() error {
				s.TextMatch.Reset()
				if err := s.TextMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_match\"")
			}
		case "text_match_info":
			if err := func() error {
				s.TextMatchInfo.Reset()
				if err := s.TextMatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_match_info\"")
			}
		case "geo_distance_meters":
			if err := func() error {
				s.GeoDistanceMeters.Reset()
				if err := s.GeoDistanceMeters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geo_distance_meters\"")
			}
		case "vector_distance":
			if err := func() error {
				s.VectorDistance.Reset()
				if err := s.VectorDistance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vector_distance\"")
			}
		case "hybrid_search_info":
			if err := func() error {
				s.HybridSearchInfo.Reset()
				if err := s.HybridSearchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hybrid_search_info\"")
			}
		case "search_index":
			if err := func() error {
				s.SearchIndex.Reset()
				if err := s.SearchIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_index\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultHit")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultHit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultHit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SearchResultHitDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SearchResultHitDocument) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SearchResultHitDocument from json.
func (s *SearchResultHitDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultHitDocument to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SearchResultHitDocumentItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultHitDocument")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchResultHitDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultHitDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultHitDocumentItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultHitDocumentItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSearchResultHitDocumentItem = [0]string{}

// Decode decodes SearchResultHitDocumentItem from json.
func (s *SearchResultHitDocumentItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultHitDocumentItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultHitDocumentItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultHitDocumentItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultHitDocumentItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SearchResultHitGeoDistanceMeters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SearchResultHitGeoDistanceMeters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes SearchResultHitGeoDistanceMeters from json.
func (s *SearchResultHitGeoDistanceMeters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultHitGeoDistanceMeters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultHitGeoDistanceMeters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchResultHitGeoDistanceMeters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultHitGeoDistanceMeters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SearchResultHitHighlight) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SearchResultHitHighlight) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SearchResultHitHighlight from json.
func (s *SearchResultHitHighlight) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultHitHighlight to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultHitHighlight")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchResultHitHighlight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultHitHighlight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultHitHybridSearchInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultHitHybridSearchInfo) encodeFields(e *jx.Encoder) {
	{
		if s.RankFusionScore.Set {
			e.FieldStart("rank_fusion_score")
			s.RankFusionScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchResultHitHybridSearchInfo = [1]string{
	0: "rank_fusion_score",
}

// Decode decodes SearchResultHitHybridSearchInfo from json.
func (s *SearchResultHitHybridSearchInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultHitHybridSearchInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rank_fusion_score":
			if err := func() error {
				s.RankFusionScore.Reset()
				if err := s.RankFusionScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank_fusion_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultHitHybridSearchInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultHitHybridSearchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultHitHybridSearchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultHitTextMatchInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultHitTextMatchInfo) encodeFields(e *jx.Encoder) {
	{
		if s.BestFieldScore.Set {
			e.FieldStart("best_field_score")
			s.BestFieldScore.Encode(e)
		}
	}
	{
		if s.BestFieldWeight.Set {
			e.FieldStart("best_field_weight")
			s.BestFieldWeight.Encode(e)
		}
	}
	{
		if s.FieldsMatched.Set {
			e.FieldStart("fields_matched")
			s.FieldsMatched.Encode(e)
		}
	}
	{
		if s.NumTokensDropped.Set {
			e.FieldStart("num_tokens_dropped")
			s.NumTokensDropped.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.TokensMatched.Set {
			e.FieldStart("tokens_matched")
			s.TokensMatched.Encode(e)
		}
	}
	{
		if s.TypoPrefixScore.Set {
			e.FieldStart("typo_prefix_score")
			s.TypoPrefixScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchResultHitTextMatchInfo = [7]string{
	0: "best_field_score",
	1: "best_field_weight",
	2: "fields_matched",
	3: "num_tokens_dropped",
	4: "score",
	5: "tokens_matched",
	6: "typo_prefix_score",
}

// Decode decodes SearchResultHitTextMatchInfo from json.
func (s *SearchResultHitTextMatchInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultHitTextMatchInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "best_field_score":
			if err := func() error {
				s.BestFieldScore.Reset()
				if err := s.BestFieldScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_field_score\"")
			}
		case "best_field_weight":
			if err := func() error {
				s.BestFieldWeight.Reset()
				if err := s.BestFieldWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_field_weight\"")
			}
		case "fields_matched":
			if err := func() error {
				s.FieldsMatched.Reset()
				if err := s.FieldsMatched.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fields_matched\"")
			}
		case "num_tokens_dropped":
			if err := func() error {
				s.NumTokensDropped.Reset()
				if err := s.NumTokensDropped.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_tokens_dropped\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "tokens_matched":
			if err := func() error {
				s.TokensMatched.Reset()
				if err := s.TokensMatched.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokens_matched\"")
			}
		case "typo_prefix_score":
			if err := func() error {
				s.TypoPrefixScore.Reset()
				if err := s.TypoPrefixScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typo_prefix_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultHitTextMatchInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultHitTextMatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultHitTextMatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchSynonym) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchSynonym) encodeFields(e *jx.Encoder) {
	{
		if s.Root.Set {
			e.FieldStart("root")
			s.Root.Encode(e)
		}
	}
	{
		e.FieldStart("synonyms")
		e.ArrStart()
		for _, elem := range s.Synonyms {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
	{
		if s.SymbolsToIndex != nil {
			e.FieldStart("symbols_to_index")
			e.ArrStart()
			for _, elem := range s.SymbolsToIndex {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfSearchSynonym = [5]string{
	0: "root",
	1: "synonyms",
	2: "locale",
	3: "symbols_to_index",
	4: "id",
}

// Decode decodes SearchSynonym from json.
func (s *SearchSynonym) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchSynonym to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "root":
			if err := func() error {
				s.Root.Reset()
				if err := s.Root.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root\"")
			}
		case "synonyms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Synonyms = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Synonyms = append(s.Synonyms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonyms\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "symbols_to_index":
			if err := func() error {
				s.SymbolsToIndex = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SymbolsToIndex = append(s.SymbolsToIndex, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols_to_index\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchSynonym")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchSynonym) {
					name = jsonFieldsNameOfSearchSynonym[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchSynonym) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchSynonym) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchSynonymDeleteResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchSynonymDeleteResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfSearchSynonymDeleteResponse = [1]string{
	0: "id",
}

// Decode decodes SearchSynonymDeleteResponse from json.
func (s *SearchSynonymDeleteResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchSynonymDeleteResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchSynonymDeleteResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchSynonymDeleteResponse) {
					name = jsonFieldsNameOfSearchSynonymDeleteResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchSynonymDeleteResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchSynonymDeleteResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchSynonymSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchSynonymSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Root.Set {
			e.FieldStart("root")
			s.Root.Encode(e)
		}
	}
	{
		e.FieldStart("synonyms")
		e.ArrStart()
		for _, elem := range s.Synonyms {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
	{
		if s.SymbolsToIndex != nil {
			e.FieldStart("symbols_to_index")
			e.ArrStart()
			for _, elem := range s.SymbolsToIndex {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSearchSynonymSchema = [4]string{
	0: "root",
	1: "synonyms",
	2: "locale",
	3: "symbols_to_index",
}

// Decode decodes SearchSynonymSchema from json.
func (s *SearchSynonymSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchSynonymSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "root":
			if err := func() error {
				s.Root.Reset()
				if err := s.Root.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root\"")
			}
		case "synonyms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Synonyms = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Synonyms = append(s.Synonyms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonyms\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "symbols_to_index":
			if err := func() error {
				s.SymbolsToIndex = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SymbolsToIndex = append(s.SymbolsToIndex, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols_to_index\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchSynonymSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchSynonymSchema) {
					name = jsonFieldsNameOfSearchSynonymSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchSynonymSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchSynonymSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchSynonymsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchSynonymsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("synonyms")
		e.ArrStart()
		for _, elem := range s.Synonyms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchSynonymsResponse = [1]string{
	0: "synonyms",
}

// Decode decodes SearchSynonymsResponse from json.
func (s *SearchSynonymsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchSynonymsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "synonyms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Synonyms = make([]SearchSynonym, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchSynonym
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Synonyms = append(s.Synonyms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonyms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchSynonymsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchSynonymsResponse) {
					name = jsonFieldsNameOfSearchSynonymsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchSynonymsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchSynonymsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StemmingDictionary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StemmingDictionary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("words")
		e.ArrStart()
		for _, elem := range s.Words {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStemmingDictionary = [2]string{
	0: "id",
	1: "words",
}

// Decode decodes StemmingDictionary from json.
func (s *StemmingDictionary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StemmingDictionary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "words":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Words = make([]StemmingDictionaryWordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StemmingDictionaryWordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Words = append(s.Words, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"words\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StemmingDictionary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStemmingDictionary) {
					name = jsonFieldsNameOfStemmingDictionary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StemmingDictionary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StemmingDictionary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StemmingDictionaryWordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StemmingDictionaryWordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("word")
		e.Str(s.Word)
	}
	{
		e.FieldStart("root")
		e.Str(s.Root)
	}
}

var jsonFieldsNameOfStemmingDictionaryWordsItem = [2]string{
	0: "word",
	1: "root",
}

// Decode decodes StemmingDictionaryWordsItem from json.
func (s *StemmingDictionaryWordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StemmingDictionaryWordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "word":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Word = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word\"")
			}
		case "root":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Root = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StemmingDictionaryWordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStemmingDictionaryWordsItem) {
					name = jsonFieldsNameOfStemmingDictionaryWordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StemmingDictionaryWordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StemmingDictionaryWordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopwordsSetRetrieveSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopwordsSetRetrieveSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stopwords")
		s.Stopwords.Encode(e)
	}
}

var jsonFieldsNameOfStopwordsSetRetrieveSchema = [1]string{
	0: "stopwords",
}

// Decode decodes StopwordsSetRetrieveSchema from json.
func (s *StopwordsSetRetrieveSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopwordsSetRetrieveSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stopwords":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Stopwords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopwords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopwordsSetRetrieveSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStopwordsSetRetrieveSchema) {
					name = jsonFieldsNameOfStopwordsSetRetrieveSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopwordsSetRetrieveSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopwordsSetRetrieveSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopwordsSetSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopwordsSetSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("stopwords")
		e.ArrStart()
		for _, elem := range s.Stopwords {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopwordsSetSchema = [3]string{
	0: "id",
	1: "stopwords",
	2: "locale",
}

// Decode decodes StopwordsSetSchema from json.
func (s *StopwordsSetSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopwordsSetSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "stopwords":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Stopwords = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Stopwords = append(s.Stopwords, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopwords\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopwordsSetSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStopwordsSetSchema) {
					name = jsonFieldsNameOfStopwordsSetSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopwordsSetSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopwordsSetSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopwordsSetUpsertSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopwordsSetUpsertSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stopwords")
		e.ArrStart()
		for _, elem := range s.Stopwords {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopwordsSetUpsertSchema = [2]string{
	0: "stopwords",
	1: "locale",
}

// Decode decodes StopwordsSetUpsertSchema from json.
func (s *StopwordsSetUpsertSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopwordsSetUpsertSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stopwords":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Stopwords = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Stopwords = append(s.Stopwords, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopwords\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopwordsSetUpsertSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStopwordsSetUpsertSchema) {
					name = jsonFieldsNameOfStopwordsSetUpsertSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopwordsSetUpsertSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopwordsSetUpsertSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopwordsSetsRetrieveAllSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopwordsSetsRetrieveAllSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stopwords")
		e.ArrStart()
		for _, elem := range s.Stopwords {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStopwordsSetsRetrieveAllSchema = [1]string{
	0: "stopwords",
}

// Decode decodes StopwordsSetsRetrieveAllSchema from json.
func (s *StopwordsSetsRetrieveAllSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopwordsSetsRetrieveAllSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stopwords":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Stopwords = make([]StopwordsSetSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StopwordsSetSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Stopwords = append(s.Stopwords, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopwords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopwordsSetsRetrieveAllSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStopwordsSetsRetrieveAllSchema) {
					name = jsonFieldsNameOfStopwordsSetsRetrieveAllSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopwordsSetsRetrieveAllSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopwordsSetsRetrieveAllSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfSuccessStatus = [1]string{
	0: "success",
}

// Decode decodes SuccessStatus from json.
func (s *SuccessStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessStatus) {
					name = jsonFieldsNameOfSuccessStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCollectionBadRequest as json.
func (s *UpdateCollectionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCollectionBadRequest from json.
func (s *UpdateCollectionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCollectionBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCollectionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCollectionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCollectionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCollectionNotFound as json.
func (s *UpdateCollectionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCollectionNotFound from json.
func (s *UpdateCollectionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCollectionNotFound to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCollectionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCollectionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCollectionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDocumentOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDocumentOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDocumentOK = [0]string{}

// Decode decodes UpdateDocumentOK from json.
func (s *UpdateDocumentOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDocumentOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDocumentOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDocumentOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDocumentOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDocumentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDocumentReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDocumentReq = [0]string{}

// Decode decodes UpdateDocumentReq from json.
func (s *UpdateDocumentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDocumentReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDocumentReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDocumentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDocumentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDocumentsBadRequest as json.
func (s *UpdateDocumentsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDocumentsBadRequest from json.
func (s *UpdateDocumentsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDocumentsBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDocumentsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDocumentsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDocumentsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDocumentsNotFound as json.
func (s *UpdateDocumentsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDocumentsNotFound from json.
func (s *UpdateDocumentsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDocumentsNotFound to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDocumentsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDocumentsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDocumentsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDocumentsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDocumentsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("num_updated")
		e.Int(s.NumUpdated)
	}
}

var jsonFieldsNameOfUpdateDocumentsOK = [1]string{
	0: "num_updated",
}

// Decode decodes UpdateDocumentsOK from json.
func (s *UpdateDocumentsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDocumentsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "num_updated":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.NumUpdated = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_updated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDocumentsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDocumentsOK) {
					name = jsonFieldsNameOfUpdateDocumentsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDocumentsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDocumentsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDocumentsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDocumentsReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDocumentsReq = [0]string{}

// Decode decodes UpdateDocumentsReq from json.
func (s *UpdateDocumentsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDocumentsReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDocumentsReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDocumentsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDocumentsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNLSearchModelBadRequest as json.
func (s *UpdateNLSearchModelBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateNLSearchModelBadRequest from json.
func (s *UpdateNLSearchModelBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNLSearchModelBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateNLSearchModelBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNLSearchModelBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNLSearchModelBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNLSearchModelNotFound as json.
func (s *UpdateNLSearchModelNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateNLSearchModelNotFound from json.
func (s *UpdateNLSearchModelNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNLSearchModelNotFound to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateNLSearchModelNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNLSearchModelNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNLSearchModelNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertAliasBadRequest as json.
func (s *UpsertAliasBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertAliasBadRequest from json.
func (s *UpsertAliasBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertAliasBadRequest to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertAliasBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertAliasBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertAliasBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertAliasNotFound as json.
func (s *UpsertAliasNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ApiResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertAliasNotFound from json.
func (s *UpsertAliasNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertAliasNotFound to nil")
	}
	var unwrapped ApiResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertAliasNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertAliasNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertAliasNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceQueryModelCollectionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceQueryModelCollectionConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ModelName.Set {
			e.FieldStart("model_name")
			s.ModelName.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoiceQueryModelCollectionConfig = [1]string{
	0: "model_name",
}

// Decode decodes VoiceQueryModelCollectionConfig from json.
func (s *VoiceQueryModelCollectionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceQueryModelCollectionConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_name":
			if err := func() error {
				s.ModelName.Reset()
				if err := s.ModelName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceQueryModelCollectionConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceQueryModelCollectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceQueryModelCollectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
